C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE NIBP_JC
OBJECT MODULE PLACED IN .\Objects\NIBP_JC.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Src\NIBP_JC.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Include) DEBUG OBJECTEXT
                    -END PRINT(.\Listings\NIBP_JC.lst) OBJECT(.\Objects\NIBP_JC.obj)

line level    source

   1          #include <SZC909.H>
   2          #include "SystemConstant.h"
   3          #include "NIBP_JC.h"
   4          #include "NIBP_ADC.h"
   5          #include "NIBP_Uart.h"
   6          #include "NIBP_APP.h"
   7          
   8          
   9          #define FFRE                0
  10          #define FRE                 1
  11          #define FP                  2   
  12          #define FEP                 3
  13          #define MAXVP_JUDGE_NUM     6
  14          
  15          #define BUFLEN          6
  16          
  17          #define DIAXISHU    70
  18          
  19          #define BPLEN       80      
  20          
  21          //用BUF来代替BUFH和BUFL   16位数据 
  22          uint16 xdata BUF[6];              
  23          
  24          uint16 xdata BPDATAP[BPLEN];
  25          
  26          uint16 xdata BPDATAV[BPLEN];
  27          
  28          //用来存放 BUF2 求平均用  对应 BUF2H:BUF2L
  29          uint16 xdata BUF2[32];
  30          
  31          uint8 xdata HRBUF[BPLEN];
  32          uint8 xdata HRBUF1[BPLEN];
  33          
  34          uint8 xdata YBUF[BPLEN];
  35          
  36          uint8 xdata VPARL[3]=       
  37          {
  38              0x32,0x32,0x2D          
  39          };
  40          
  41          uint8 xdata VPARH[3]=     
  42          {
  43              0x96,0x87,0x87         
  44          };
  45          
  46          
  47          bit FIRST8;             //找到首次上升沿 标志位
  48          bit NEGF;               //检测结束时用
  49          bit HRERR;
  50          bit IHB;
  51          bit SBFLAG;
  52          
  53          bit MAXPRE_UP_FLAG=0;       //压力上升台阶标志位
  54          
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 2   

  55          uint8 xdata BP_SHOW_STOP;       //心跳标志显示暂停标志
  56          
  57          
  58          //在首次上升沿前   BUF2 16次相加的总和 取代BUF2H:BUF2L
  59          uint32 xdata BUF2_VAL;
  60          
  61          //取代LASTH:LASTL    首次上升沿前 16次数据的上一次平均
  62          uint16 xdata LAST_AVG;     
  63          
  64          
  65          uint8 xdata COUNT3;
  66          uint8 xdata MAXV072;
  67          uint8 xdata PHASE;
  68          uint8 xdata PPRO;
  69          //uint8 xdata RTCOUNTL;
  70          uint8 xdata COUNT,COUNT1;             //COUNT1在高8位 COUNT在低8位
  71          uint8 xdata IPTR2;
  72          uint8 xdata BPPTR;
  73          uint8 xdata LASTL;
  74          uint8 xdata LASTH;
  75          uint8 xdata OFFCL;
  76          uint8 xdata HEARTCNT;
  77          
  78          uint8 xdata H_HEART_C;
  79          uint8 xdata DISPTIME;
  80          uint8 xdata BPTR;
  81          uint8 xdata BPTR_Temp;
  82          uint8 xdata MAXVP;
  83          
  84          uint8 xdata RATIOTMP;
  85          uint8 xdata SYSL;
  86          uint8 xdata DIAL;
  87          uint8 xdata PDIA;
  88          uint8 xdata PSYS;
  89          uint8 xdata PHR;
  90          
  91          //最后用来放置高低压和心率的参数
  92          uint16 xdata SYSL_VAL;      //收缩压   改为16位数据
  93          uint16 xdata DIAL_VAL;      //舒张压   改为16位数据
  94          uint8 xdata PHR_VAL;        //心率 
  95          
  96          uint8 xdata MAXH;
  97          //uint8 xdata MAXVP_DATE_0,MAXVP_DATE_1,MAXVP_DATE_M;
  98          
  99          uint8 xdata OPTR;
 100          uint8 xdata YPTR;    
 101          
 102          //用来替换汇编程序中的STARTPL,STARTPH
 103          uint16 xdata STARTP;
 104          
 105          //用来替换汇编程序中的PEAKPL,PEAKPH
 106          uint16 xdata PEAKP;
 107          
 108          //压力台阶  在C语言里应用  流程已与汇编程序同步
 109          uint32 xdata MAXPRE;
 110          uint32 xdata MAXEND;
 111          uint32 xdata MAXSTEP;
 112          
 113          //BEGINPH在低8位 BEGINPL在高8位
 114          uint16 xdata BEGINP;
 115          
 116          
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 3   

 117          uint8 xdata JCDFLAG;
 118          
 119          uint16 xdata VAVG;
 120          uint8 xdata Y;
 121          
 122          //uint8 xdata CHGI0,CHGI1,CHGI2,CHGI3;
 123          
 124          uint8 xdata PA0,PA1,PA2,PA3,PA4,PA5,PA6,PA7;
 125          
 126          uint16 xdata PA1_PA0,PA3_PA2,PA5_PA4,PA7_PA6;
 127          
 128          uint32 xdata PA2_PA1_PA0;
 129          
 130          uint8 xdata PB2,PB3;
 131          uint16 xdata PB3_PB2;
 132          
 133          uint8 xdata RR0,RR1,RR2,RR3,RR4,RR5,RR6,RR7;    //替代 R0-R7
 134          
 135          //用来替换汇编程序中 BASEDTH,BASEDTL
 136          uint16 xdata BASEDT_VAL;
 137          
 138          //替换汇编程序中 BATENL,BATENH
 139          uint16 xdata BATEN;
 140          //uint8 xdata BATENH;
 141          //uint8 xdata BATENL;
 142          
 143          //通用暂存8位数据变量
 144          uint8 xdata AA,XX,BB,CC,HH,LL;
 145          
 146          //通用暂存16位数据变量
 147          uint16 xdata AX,BC,HL,DE;
 148          
 149          //主检测流程 标志
 150          uint8 NIBP_JC_FSM=0;
 151                                            
 152          
 153          /****************************************************
 154          检测开始前的初始化部分
 155              用于一些参数及标志位的定义
 156          *****************************************************/
 157          void JC_Init(void)       
 158          {
 159   1          COUNT3=0;             
 160   1          FIRST8=1;           
 161   1          MAXV072=0;              //低压点检出标志
 162   1          PHASE=FFRE;             //置检测阶段标志初始化标志  FFRE=0                                
 163   1          PPRO=0;                 //后处理指针
 164   1      //    RTCOUNTL=0;             //实时时间计?器RTCOUNTH与TCOUNTH共用
 165   1      
 166   1          COUNT=0;                //峰宽
 167   1          IPTR2=0;                //心跳队列指针
 168   1          BPPTR=0;                //
 169   1          
 170   1          Y=8;                    //初始化的时候 Y先=8
 171   1      
 172   1          LAST_AVG=0;             //起始时,16位数据取平均用        
 173   1                                                
 174   1          DISPTIME=0;                        
 175   1          BPTR=0;
 176   1          BPTR_Temp=0;            //重新定义一个新的，解决心率出错的问题  
 177   1          
 178   1          HEARTCNT=0;
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 4   

 179   1          IHB=0;
 180   1          HRERR=0;
 181   1          
 182   1          SYSL=0;
 183   1          DIAL=0;
 184   1          PHR=0;
 185   1          SYSL_VAL=0;
 186   1          DIAL_VAL=0;
 187   1          PHR_VAL=0;
 188   1      
 189   1          YPTR=0;
 190   1          
 191   1          MAXPRE_UP_FLAG=0;        //压力上升台阶用
 192   1          
 193   1          OFFCL=30;      
 194   1          
 195   1          BASEDT_VAL=8000;        
 196   1              
 197   1      } 
 198          
 199          /********************************************************
 200          检测流程
 201              初始化完成之后 弃掉前30个值 再JCL
 202          *********************************************************/
 203          void NIBP_Calculation(void)
 204          {  
 205   1          switch(NIBP_JC_FSM)
 206   1          {
 207   2              case 0:
 208   2              {
 209   3                  JC_Init();              //检测初始化部分
 210   3      
 211   3                  NIBP_JC_FSM=1;          //转下一流程
 212   3                  
 213   3                  break;
 214   3              }
 215   2              case 1:
 216   2              {   
 217   3                  ACQDATA();              //采集一下送BUF
 218   3      
 219   3                  OPTRINC();              //OPTR+1一次
 220   3        
 221   3                  OFFCL--;                    //OFFCL减1 一次 直到为0
 222   3                  
 223   3                  if(OFFCL==0) 
 224   3                      NIBP_JC_FSM=2;      //转下一流程
 225   3                      
 226   3                  break;
 227   3              }
 228   2              case 2:
 229   2              {    
 230   3                  NIBP_JC_Result();        //等同于汇编程序里的JCL:  
 231   3      
 232   3                  break;
 233   3              }
 234   2              default:
 235   2                  break;
 236   2          }
 237   1      
 238   1      }
 239          
 240          /************************************************************
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 5   

 241          程序里一次循环的检测过程 
 242          相当于汇编程序里的JCL
 243          到最后一个 } 检测过程结束
 244          *************************************************************/
 245          void NIBP_JC_Result(void)
 246          {
 247   1          ACQDATA();                  //采集一下送BUF
 248   1          
 249   1          UART_Tx_Data5x(BUF[OPTR]);      //--------------- 串口传输当前BUF值   压力值=当前BUF值/80 ------------
             ----
 250   1          
 251   1          if(BPPTR<5)                
 252   1          {
 253   2              JCL2();               
 254   2          }
 255   1          else
 256   1          {
 257   2              if(MAXV072==0)          
 258   2              {
 259   3                  JCL2();            
 260   3              }
 261   2              else
 262   2              {
 263   3                  if(COUNT<0x64)      //当COUNT<100的时候   
 264   3                  {
 265   4                      JCL2();         //跳JC2
 266   4                  } 
 267   3                  else                //否则直接结束
 268   3                  {
 269   4                      JCL1();         //检测过程结束
 270   4                  }
 271   3              }            
 272   2          }
 273   1      }
 274          
 275          
 276          /*********************************************************
 277          直接结束过程
 278          跳转到DEND()函数
 279          **********************************************************/
 280          void JCL1(void)         
 281          {    
 282   1           DEND();   
 283   1      }
 284          
 285          /**********************************************************
 286          开始检测过程
 287          取到 BUF[OPTR]的值 必须>25mmHg
 288          ***********************************************************/
 289          void JCL2(void)            
 290          {   
 291   1          BC=LDOPTRA(0);               //先取出当前的BUF[OPTR]  数据放在BC=BUF[OPTR]
 292   1      
 293   1          PA1_PA0=BASEDT_VAL*25/100;   //判断当前的压力值是否有问题 8000*25/100=2000   25mmHg 
 294   1          
 295   1          if(BC<PA1_PA0)               //当前采集到的值>2000 25mmhg       
 296   1          {
 297   2              DEND();                  //压力<25mmHg, 强制结束  
 298   2          } 
 299   1          else                         //当前的压力值大于25mmHg 就往下计算
 300   1          {
 301   2              AX=BC-PA1_PA0;         
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 6   

 302   2              
 303   2              JCL5();                  //如果当前压力值>25mmHg 跳JCL5                            
 304   2          }
 305   1      }
 306          
 307          /*************************************************************
 308          当前检测到的BUF值 
 309              满足>25mmHg的时候  继续计算
 310              COUNT过大 要清0
 311          *************************************************************/
 312          void JCL5(void)             
 313          {
 314   1          if(COUNT<250)               
 315   1          {
 316   2              JCL51();
 317   2          }
 318   1          else
 319   1          {    
 320   2              PHASE=FFRE;             //PHASE=0
 321   2              COUNT=0;                //计数过大   COUNT清空
 322   2              
 323   2              BP_SHOW_STOP=2;         //显示暂停标志
 324   2              
 325   2              JCL51();                //跳转JCL51
 326   2          }
 327   1          
 328   1      }
 329          
 330          /***************************************************************
 331          比较完COUNT<250的以后 进入以下计算流程
 332          取BUF[OPTR-1]             放置在PA1_PA0里
 333          并与BUF[OPTR]进行比较     放置在BC里    与上面的进行比较
 334          如果两点之间的差 大于4mmHg 升一个压力台阶 
 335          ****************************************************************/
 336          void JCL51(void)          
 337          {
 338   1          if(BPPTR>=5)       
 339   1          {
 340   2              JCL6();        
 341   2          }
 342   1          else
 343   1          {        
 344   2              PA1_PA0=LDOPTRA(1);             //取BUF[OPTR-1]的值   放在PA1_PA0里
 345   2                                
 346   2              if(PA1_PA0>BC) 
 347   2              {
 348   3                  PB3_PB2=PA1_PA0-BC;   
 349   3              }            
 350   2              else 
 351   2              {
 352   3                  PB3_PB2=BC-PA1_PA0;          //取两个相差的值  存在PB3_PB2里 
 353   3              }
 354   2              
 355   2              PA1_PA0=BASEDT_VAL*4/100;        //320   4mmHg   
 356   2              
 357   2              if(PB3_PB2<PA1_PA0)             //前一个点与当前这个点 相差4mmHg的话           
 358   2              {
 359   3                  AX=PB3_PB2-PA1_PA0;       
 360   3              
 361   3                  JCL6();                     //当前后两点的差值 在正常范围内 JCL6      
 362   3              }
 363   2              else                            //第一次重入判断 前后两个值相差超过4mmHg
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 7   

 364   2              {
 365   3                  AX=PB3_PB2-PA1_PA0;       
 366   3                     
 367   3                  MAXPREUP();                 //压力平台处理 更新当前压力台阶 190 230 270 300
 368   3      
 369   3                  UART_Tx_String("MAXPREUP_1");
 370   3                  UART_Tx_String("\r\n");
 371   3                  
 372   3                  if(AA==0)                   //AA返回0 是因为压力台阶到300了
 373   3                  {
 374   4                      JCL6();                 //压力平台处理结束后 当AA=0时 跳JCL6 
 375   4                      
 376   4                  }
 377   3                  else
 378   3                  {
 379   4                      JCL81();
 380   4                  }
 381   3              }
 382   2          }
 383   1      }
 384          
 385          /*******************************************************************
 386          JCL81函数  
 387              重入判断时 跳转运行到这
 388          ********************************************************************/
 389          void JCL81(void)
 390          {
 391   1          FIRST8=1;
 392   1          
 393   1          MAXPRE_UP_FLAG=1;        //置高后  去APP.c中去判断
 394   1      }
 395          
 396          /******************************************************************
 397          当BUF[OPTR-1]与BUF[OPTR]相减 <4mmHg的时候进行计算
 398          进来一次    COUNT会加1一次    COUNT用来计次用
 399                      PPRO会清0
 400          ******************************************************************/
 401          void JCL6(void)         
 402          {
 403   1          COUNT=COUNT+1;              //数据满足条件的进来加 COUNT+1一次
 404   1          
 405   1          PPRO=0;                     //后处理标志清0
 406   1          
 407   1          if(COUNT<100)                //如果COUNT<80 直接跳JCL7
 408   1          {
 409   2              JCL7();            
 410   2          }
 411   1          else                        //COUNT>=80 JCDFLAG.4置高 再跳JCL7
 412   1          {
 413   2              JCDFLAG=JCDFLAG|0x10;   
 414   2                                     
 415   2              JCL7();
 416   2          } 
 417   1      }
 418          
 419          /******************************************************************
 420          JCL7函数
 421              当COUNT+1一次以后  进入判断
 422              HTCOUNT0 跳转运行方式
 423              BPPTR<5,先要将数据 送TOBUF2一次  16次数据算平均
 424          ********************************************************************/
 425          void JCL7(void)
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 8   

 426          {
 427   1          if(BPPTR>=5)        
 428   1          {
 429   2              HTCOUNT0();        
 430   2          }
 431   1          else                    //BPPTR<5的时候  要先进行TOBUF2()一次
 432   1          {
 433   2              TOBUF2();           //测量值送入BUF2 同时IPTR2加1一次 BUF2[IPTR2]=BUF[OPTR]
 434   2              HTCOUNT0();     
 435   2          }
 436   1      }
 437             
 438          /*****************************************************************
 439          根据PHASE的条件  来选择检测方式
 440          **PHASE=0   首次上升沿检出
 441          **PHASE=1   上升沿检出
 442          **PHASE=2   峰值检出
 443          **PHASE=3   结束点检出
 444          
 445          **当最初始的时候  PHASE=0 
 446          ******************************************************************/
 447          void HTCOUNT0(void)     
 448          {     
 449   1          if(PHASE==0)
 450   1          {
 451   2              FFREADR();              //首次上升沿检出
 452   2          }
 453   1          else
 454   1          {
 455   2              if(PHASE==1)
 456   2              {
 457   3                  FREADR();           //上升沿检出
 458   3              }
 459   2              else
 460   2              {
 461   3                  if(PHASE==2)
 462   3                  {
 463   4                      FPADR();        //峰值检出
 464   4                  }
 465   3                  else
 466   3                  {
 467   4                      if(PHASE==3)
 468   4                      {
 469   5                          FEPADR();   //结束点检出
 470   5                      }
 471   4                  }
 472   3              }
 473   2          }
 474   1      }
 475          
 476          /****************************************************************
 477          进入首次上升沿检出过程
 478          FIRST8 置低之前  一直进入FFRE1()
 479          前48个数据算出VAVG和Y后,FIRST8置低 直接求满足3个小于Y条件 
 480          不满足3个条件的话 再算一次16数据平均
 481          满足的话 PPRO=1  
 482                   PHASE=2  后处理一次 进入峰值检出 
 483          ****************************************************************/
 484          void FFREADR(void)    
 485          {
 486   1          if(FIRST8)          
 487   1          {
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 9   

 488   2              FFRE1();            
 489   2          }
 490   1          else
 491   1          {
 492   2              DRE();              //首次上升沿的时候 不满足条件的话 AA=0
 493   2          
 494   2              if(AA==0)           //不满足连续3个小Y的条件  AA=0
 495   2              {
 496   3                  FFRE1();        //后处理一次  再TOBUF2的时候  IPTR2加1一次    
 497   3              }  
 498   2              else                //满足了连续3个小Y的条件
 499   2              {   
 500   3                  PPRO=1;         //让PPRO置1                     
 501   3                  PHASE=FP;       //PHASE=2      找到首次上升沿
 502   3                  FFRE0();        //找到首次上升沿后 进入后处理一下
 503   3              }  
 504   2          }        
 505   1      }
 506              
 507          /***********************************************************
 508          进入到后处理
 509          ***********************************************************/
 510          void FFRE0(void)              
 511          {  
 512   1          POSTP();      //直接进入后处理          
 513   1      }
 514          
 515          /***************************************************************
 516          IPTR2加到16的时候   计算一次BUF16次的平均值
 517              否则 进入后处理一次
 518          ****************************************************************/
 519          void FFRE1(void)         
 520          {     
 521   1          if(BPPTR||IPTR2)        //BPPTR必须等于0
 522   1          {       
 523   2              FFRE0();            //当IPTR2没有加到16次 则继续POSTP
 524   2          }
 525   1          else                    //当IPTR2等于0了  也就是取到16次的值了
 526   1          {       
 527   2              FFRE2();            //当16次了 取平均
 528   2          }             
 529   1      }
 530          
 531          /********************************************************************
 532          CALBUF2: 取16次的平均值  放在PA5_PA4里
 533          如果上一次的平均 LAST_AVG=0的话  LAST_AVG=PA5_PA4
 534          上一次的平均 LAST_AVG不为0的话  进入FFRE23 算VAVG
 535          *********************************************************************/
 536          void FFRE2(void)         
 537          {    
 538   1          CALBUF2();                  //取BUF2里的平均值 PA5_PA4为当前平均值  
 539   1      
 540   1          if(LAST_AVG!=0)                        
 541   1          {
 542   2              FFRE23();               //进入计算VAVG          
 543   2          }
 544   1          else                        //首次16个平均算出来前 LAST_AVG=0
 545   1          {
 546   2              LAST_AVG=PA5_PA4;       //如果上一次的LAST_AVG是0 则直接取PA5_PA4            
 547   2              POSTP();                
 548   2          }
 549   1      }
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 10  

 550                               
 551          /********************************************************************
 552          计算VAVG
 553          上一次的平均值LAST_AVG - 这次的平均值PA5_PA4 后
 554          得出的结果 * 0.85   就是求得的VAVG  放在 **PA1_PA0** 里
 555          如果这次的平均大于上次平均  VAVG=PA1_PA0=0
 556          ********************************************************************/
 557          void FFRE23(void)          
 558          {
 559   1          if(LAST_AVG>=PA5_PA4)             
 560   1          {                               
 561   2              PA1_PA0=LAST_AVG-PA5_PA4;   //取两个平均值的差值
 562   2              
 563   2              LAST_AVG=PA5_PA4;           //同时 更新LAST_AVG
 564   2              
 565   2              PA1_PA0=PA1_PA0*85/100;     //求出VAVG
 566   2              
 567   2              FFRE3();                    //满足条件的情况后,进入FFRE3               
 568   2          }                              
 569   1          else                                           
 570   1          {                                                         
 571   2              PA1_PA0=0;                  //上一次平均值比这次小              
 572   2                                         
 573   2              FFRE3();                    
 574   2          }
 575   1      }
 576          
 577          /******************************************************************
 578          把PA1_PA0的值 也就是VAVG 代入计算出Y
 579          如果VAVG的值大于255的话 就取255  
 580          VAVG不能大于255
 581          PA1_PA0代入 CALY()
 582          Y=VAVG/16*85/100
 583          DIPSTIME 加1  当为0的时候 只算出首个平均
 584          DIPSTIME 到2的时候   相当于通过两次平均 算出VAVG和Y 
 585          *******************************************************************/
 586          void FFRE3(void)          
 587          {               
 588   1          if(PA1_PA0>255)            
 589   1          {
 590   2              PA1_PA0=255;        //PA1_PA0的值 最大取255       
 591   2          }                              
 592   1                                      
 593   1          VAVG=PA1_PA0;           //VAVG=PA1_PA0        
 594   1          
 595   1          CALY();                 //计算出Y的值 
 596   1      
 597   1          if(DISPTIME>=3)         //DIPSTIME起始的时候0  
 598   1          {
 599   2              FFRE9();             
 600   2          }  
 601   1          else
 602   1          {
 603   2              DISPTIME=DISPTIME+1;    //满足16次平均后 DISPTIME加1一次   
 604   2                                
 605   2              if(DISPTIME>=3)            
 606   2              {
 607   3                  FFRE9();            //通过前48个值 算出VAVG和Y之后 进入FFRE9           
 608   3              }
 609   2              else
 610   2              {
 611   3                  FFREEND();          //进入一次后处理    
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 11  

 612   3              }
 613   2          }        
 614   1      }
 615          
 616          /******************************************************************
 617          当取到前48个值的时候   也就是第二次通过16次平均算出的VAVG和Y后
 618              把FIRST8给置低  后面就一直是找首次上升沿了 找不到就16次值更新VAVG和Y
 619              同时BEGINP=BUF[0]  也就是当前BUF   也就是48个点的时候的压力值
 620              进入后处理一次
 621          *******************************************************************/
 622          void FFRE9(void)          
 623          {
 624   1          if(FIRST8==0) 
 625   1          {
 626   2              FFREEND();    //算出一次VAVG DISPTIME+1一次 算到第2次VAVG的时候
 627   2          }
 628   1          else
 629   1          {
 630   2              FIRST8=0;          //当取到48个值的时候 算出第2个VAVG FIRST8置0                              
 631   2          
 632   2              BEGINP=BUF[0];     //BEGINP=BUF[0] 取到第48个点的压力值 大概在175mmHg
 633   2              
 634   2              UART_Tx_String("BEGINP:");
 635   2              UART_Tx_Data5x(BEGINP); 
 636   2          
 637   2              FFREEND();
 638   2          }
 639   1      }
 640          
 641          /***************************************************************
 642          进入到后处理
 643          ****************************************************************/
 644          void FFREEND(void)        
 645          {    
 646   1          POSTP();                    //进入后处理
 647   1      }
 648          
 649          /**************************************************************
 650          上升沿检出
 651          DRE 不满足3个<Y的时候 AA=0
 652          当找到上升沿的时候  PPRO=2   PHASE=2
 653          BPTR+1一次 
 654          ACALVAVG()  算出新VAVG  新Y
 655          **************************************************************/
 656          void FREADR(void)      
 657          {
 658   1          DRE();                           
 659   1          
 660   1          if(AA==0)             
 661   1          {
 662   2               FFREEND();        
 663   2          }  
 664   1          else                   
 665   1          {
 666   2              if(COUNT<0x16)           // 579 此处 0x16                
 667   2              {
 668   3                  FFREEND();        
 669   3              }
 670   2              else                   
 671   2              {
 672   3                  PPRO=2;             //当满足以上条件的时候 PPRO=2
 673   3                  PHASE=FP;           //PHASE=2   进入峰值检出  
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 12  

 674   3          
 675   3      //            if(BPTR>=BPLEN)
 676   3      //            {
 677   3      //                BB=BPTR-BPLEN;
 678   3      //            }
 679   3      //            else
 680   3      //            {
 681   3      //                BB=BPTR;       //起始的时候 BPTR=0  
 682   3      //            }   
 683   3      
 684   3                  BB=BPTR&0x1F;
 685   3                  
 686   3                  HRBUF[BB]=COUNT-4;  //HRBUF[]存心率间隔的值
 687   3                  
 688   3      //            UART_Tx_String("BPTR:");
 689   3      //            UART_Tx_Data3x(BPTR); 
 690   3      //            UART_Tx_String("BPTR_Temp:");
 691   3      //            UART_Tx_Data3x(BPTR_Temp);
 692   3      
 693   3                  BPTR++;             //BPTR加1一次
 694   3                  BPTR_Temp++;
 695   3          
 696   3                  ACALVAVG();         //算出新的VAVG 新Y
 697   3          
 698   3                  FREEND();           //结束
 699   3              }
 700   2          }
 701   1      }
 702          
 703          /********************************************************************
 704          进入到后处理过程
 705          ***********************************************************************/
 706          void FREEND(void)      
 707          {
 708   1          POSTP();              
 709   1      }
 710          
 711          /*******************************************************************
 712          峰值检出过程
 713          先DPEAK()一下 找出PEAKP后 结束点检出
 714          DPEAK() 只有当满足条件后 且COUNT>17时 返回1
 715          *********************************************************************/
 716          void FPADR(void)          
 717          {
 718   1          AA=DPEAK();             //DPEAK()一下 找出PEAKP的值 A=0
 719   1          
 720   1          if(AA!=1)               //A=0的时候      
 721   1          {
 722   2              if(COUNT1<0x15)     //COUNT1要小于21     
 723   2              {
 724   3                  FPEND();        //进入后处理 
 725   3              }
 726   2              else                //COUNT1要是大于21了 重新找首次上升沿了
 727   2              {
 728   3                  PHASE=FFRE;     //PHASE=0
 729   3                  FPEND(); 
 730   3              }
 731   2          } 
 732   1          else                    //AA=1的时候   且COUNT>=16  COUNT-COUNT1>=6
 733   1          {
 734   2              PHASE=FEP;          //PHASE=3    进入结束点检出        
 735   2         
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 13  

 736   2              if(COUNT1<0x15)          
 737   2              {        
 738   3                  FPEND(); 
 739   3              }
 740   2              else
 741   2              {
 742   3                  PHASE=FFRE;     //PHASE=0
 743   3                  FPEND();
 744   3              }            
 745   2          }
 746   1                           
 747   1      }
 748          
 749          /************************************************************
 750          后处理过程
 751          *************************************************************/
 752          void FPEND(void)     
 753          {
 754   1          POSTP();          
 755   1      }
 756          
 757          
 758          /*******************************************************************
 759          结束点检出过程
 760          取到BUF[OPTR]的值
 761          和STARTP进行比较
 762          *********************************************************************/
 763          void FEPADR(void)            
 764          {
 765   1          PA1_PA0=LDOPTRA(0);         //取当前的BUF[OPTR]的值
 766   1          
 767   1          if(STARTP<PA1_PA0)
 768   1          {   
 769   2              if(COUNT>=0x33)
 770   2              {
 771   3                  PHASE=FFRE;         //PHASE=0 重新找首次上升沿
 772   3                  FPEND(); 
 773   3              }
 774   2              else
 775   2              {
 776   3                  FEPEND();
 777   3              }
 778   2          }
 779   1          else
 780   1          {
 781   2              PHASE=FRE;              //PHASE=1 进入上升沿检出过程
 782   2              FEPEND();
 783   2          }
 784   1      }
 785          
 786          /************************************************************
 787          后处理过程
 788          *************************************************************/
 789          void FEPEND(void)        
 790          {
 791   1          POSTP();                  
 792   1      }
 793          
 794          /*****************************************************************
 795          -------后处理过程 -----------------
 796          
 797          ********************************************************************/
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 14  

 798          void POSTP(void)           
 799          {
 800   1          AX=LDOPTRA(0);          //取到当前的 BUF[OPTR] 放在AX里
 801   1          
 802   1          if(AX>=1600)            //579 此处 1000       
 803   1          {
 804   2              POSTPA();           //如果BUF>=20mmHg 跳POSTPA 
 805   2          }   
 806   1          else
 807   1          {
 808   2              POSTPB();           //当某时 压力小于 20mmHg 就报错
 809   2              
 810   2              UART_Tx_String("ERR_1");
 811   2              UART_Tx_String("\r\n");
 812   2          }
 813   1      }
 814          
 815          
 816          //;---------------------modify_27_01-------------------------
 817          void POSTPB(void)           //POSTPB:
 818          {
 819   1            TZH();
 820   1      }
 821          
 822          
 823          /***********************************************************
 824          当前值BUF[OPTR]>20mmHg后,才能进入POSTPA
 825              COUNT<125的时候  跳POSTP0
 826          *************************************************************/
 827          void POSTPA(void)        
 828          {       
 829   1          if(COUNT<0x7D)                
 830   1          {
 831   2              POSTP0();              
 832   2          }
 833   1          else                        //COUNT>=125 处理
 834   1          {
 835   2              if(PHASE!=FRE)          //PHASE不等于1 不在上升沿检出状态         
 836   2              {
 837   3                  POSTP02();          //跳POSTP02
 838   3              }
 839   2              else                    //PHASE=1时 代表上升沿检出状态
 840   2              {
 841   3                  POSTP01();         
 842   3              }
 843   2          }
 844   1      }
 845          
 846          /*************************************************************
 847          当COUNT>125 PHASE=1的时候   就跳POSTP01了
 848          让PPRO=2  进入到POSTP03
 849          PHASE=1的时候  就是上升沿检出过程  
 850          PHASE=2的话  峰值检出
 851          *************************************************************/
 852          void POSTP01(void)   
 853          {
 854   1          PPRO=2;             //在上升沿检出状态时 要让PPRO置2
 855   1          
 856   1          POSTP03();       
 857   1      }
 858          
 859          /*************************************************************
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 15  

 860          当COUNT>125 PHASE不等于1的时候  跳进来
 861          PHASE不等于1 也就是 不是上升沿检出过程
 862          执行函数之后 要往后执行POSTP03
 863          将COUNT的值 重置成5
 864          *************************************************************/
 865          void POSTP02(void)  
 866          {    
 867   1          PA1_PA0=LDOPTRA(5);        
 868   1          
 869   1          STARTP=PA1_PA0;             //让STARTP=BUF[OPTR-5]
 870   1          
 871   1          COUNT=5;                    //让COUNT=5
 872   1      
 873   1          POSTP03();             
 874   1      }
 875          
 876          /************************************************************
 877          POSTP03函数
 878          只是执行一下  让PHASE=0  往后执行POSTP0()
 879              PHASE=0 让重新找出首次上升沿
 880          *************************************************************/
 881          void POSTP03(void)   
 882          {
 883   1          PHASE=FFRE;         
 884   1          
 885   1          POSTP0();              
 886   1      }
 887          
 888          /**********************************************************
 889          POSTP0处理函数   
 890          当COUNT<125的时候  直接进入
 891          PPRO平时=0           直接跳POSTP2
 892          首次上升沿找到时 PPRO=1 直接跳POSTP2
 893          ***********************************************************/
 894          void POSTP0(void)     
 895          {    
 896   1          if(PPRO==2)             //只有当PPRO=2的时候跳POSTP0YT 找到首次上升沿PPRO=1 找到上升沿PPOR=2        
 897   1          {        
 898   2              POSTP0YT();         //找到上升沿时 PPRO=2 进入POSTP0YT     
 899   2          }
 900   1          else
 901   1          {
 902   2              POSTP2();         
 903   2          }        
 904   1      }
 905          
 906          /*************************************************************
 907          POSTP0YT函数
 908          当PPRO=2的时候 进入  PPRO在上升沿找到后 进入 
 909          先得重新算 PEAKP 
 910              重入条件：
 911                  CALPEAK()一次
 912                  BPPTR<3 只能是刚有几次上升沿
 913                  COUNT<7 也不用 去掉 太靠近BEGIP的点
 914                  BEGINP 也就是 48个点的时候的当前压力值
 915                  BEGINP与第2次上升沿 相差只有16mmHg的时候 要重入了
 916          *************************************************************/
 917          void POSTP0YT(void)      
 918          {    
 919   1          CALPEAK();          //算出新的PEAKP
 920   1          
 921   1          //-------重入判断-----------------          
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 16  

 922   1          if(BPPTR>=3)        
 923   1          {        
 924   2              PCHREND();      //当BPPTR>=3了之后直接跳 峰值去干扰   
 925   2          }
 926   1          else
 927   1          {
 928   2              if(COUNT1<7)        
 929   2              {        
 930   3                  PCHREND();         
 931   3              }
 932   2              else
 933   2              {    //不满足以上的情况  往下执行
 934   3                  if(PEAKP<0x4A)      //PEAKP<74
 935   3                  {
 936   4                      PCHREND();     
 937   4                  }
 938   3                  else
 939   3                  {
 940   4                      if((BEGINP-1280)>=STARTP)      //1280/80=16mmHg
 941   4                      {
 942   5                          PCHREND();
 943   5                      }
 944   4                      else    //BEGINP 如果与首次上升沿STARTP 相差小于16mmHg的话  就跳压力台阶
 945   4                      {
 946   5                          MAXPREUP();         //压力平台处理 更新当前压力台阶 190 230 270 300
 947   5      
 948   5                          UART_Tx_String("MAXPREUP_2");
 949   5                          UART_Tx_String("\r\n");
 950   5                          
 951   5                          if(AA==0)
 952   5                          {
 953   6                              PCHREND();              //已经超过300了  应该直接报错
 954   6                          }
 955   5                          else                  
 956   5                          {
 957   6                              JCL81();                //跳JCL81  重新进行计算
 958   6                          }
 959   5                      }
 960   4                  }
 961   3              }
 962   2          }
 963   1      }
 964          
 965          /**********************************************************
 966          //峰值去干扰
 967          当PEAKP>=1024的时候 直接进入到 POSTP3    
 968          否则 TOBP一下 BPPTR+1一次之后 再ENOISE一次  进POSTP3
 969          
 970              TOBP函数  存BPDATAP  当前压力值-30
 971                          BPDATAV  PEAKP>>2   验证没有问题   
 972                          BPPTR+1后 更新BPDATAP[BPPTR] BPDATAV[BPPTR]
 973          ***********************************************************/
 974          void PCHREND(void)        
 975          {  
 976   1          if((PEAKP>=0x0400)||(PEAKP<12))     //2018.5.15 加    
 977   1          {
 978   2              POSTP3();           //如果PEAKP>1024的话 进POSTP3 
 979   2          }      
 980   1          else
 981   1          {  
 982   2              TOBP();             //存数据在BPDATAP BPDATAV   
 983   2                                  //BPPTR 在不满足条件的时候 会减1一次 
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 17  

 984   2              BPPTR=BPPTR+1;      //BPPTR+1一次
 985   2          
 986   2              ENOISE();        
 987   2      
 988   2              POSTP3();  
 989   2          }        
 990   1      }
 991          
 992          /*********************************************************
 993          POSTP2处理函数 
 994          PPRO平时=0       直接再JCL一次
 995          首次上升沿找到后 PPRO=1  跳POSTP3
 996          **********************************************************/
 997          void POSTP2(void)         
 998          { 
 999   1          if(PPRO==1)         //首次上升沿找到PPRO=1  没找到首次上升沿,进POSTPMC
1000   1          {
1001   2              POSTP3();           
1002   2          } 
1003   1          else
1004   1          {
1005   2              POSTPMC();          //否则 再JCL一次
1006   2          }
1007   1      }
1008          
1009          /***********************************************************
1010          当首次上升沿之后,会进来一次  
1011          COUNT=4
1012              PEAKP等于  BUF[OPTR] 当PA6=0的时候
1013              STARTP等于 BUF[OPTR-4]
1014              这两个数据 在后面一次上升沿时候用到
1015          DMPEAK() 函数在首次上升沿的时候 BPPTR=0时  基本直接返回 跳POSTPM4
1016          BPDATAP[]存 上升沿压力值
1017          ************************************************************/
1018          void POSTP3(void)        
1019          {   
1020   1          JCDFLAG=JCDFLAG&0xEF;       //JCDFLAG.4 清空是什么意思   
1021   1          
1022   1          COUNT=4;                    //只要找到上升沿时,让COUNT=4    
1023   1          
1024   1          DRE();                      //再进入 DRE  AA=PA4-2 PA0=4-PA6                        
1025   1                                    
1026   1          COUNT1=PA0;                                        
1027   1          AA=COUNT-COUNT1;           
1028   1      
1029   1          PEAKP=LDOPTRA(AA);          //PEAKP=BUF[OPTR]    重新取值到 PEAKP=BUF[OPTR]    
1030   1      
1031   1          STARTP=LDOPTRA(4);          //STARTP=BUF[OPTR-4]    重新取值到 STARTP=BUF[OPTR-4]
1032   1      
1033   1          //----------------此处增加心跳符号------------------
1034   1          HEARTCNT=10;        //心跳符号显示
1035   1          BP_SHOW_STOP=2;         //显示暂停标志
1036   1          
1037   1          DMPEAK();           //BPPTR=0的时候 直接返回    求出 MAXVP 最大的值
1038   1          
1039   1          if(BPPTR==0)               
1040   1          {
1041   2              POSTPM4();   
1042   2          }  
1043   1          else            
1044   1          {
1045   2              HL=BPPTR;
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 18  

1046   2              HL=HL-1;
1047   2              
1048   2              AA=BPDATAP[HL];         //取BPDATAP[BPPTR-1]中的值      
1049   2          
1050   2              if(AA>=0x78)        
1051   2              {        
1052   3                  POSTPM4();           
1053   3              }
1054   2              else
1055   2              {                 
1056   3                  if(AA<0x3C)     
1057   3                  {    
1058   4                      PA5=3;              
1059   4                      POSTM3();          
1060   4                  }
1061   3                  else
1062   3                  {
1063   4                      PA5=5;         
1064   4                      POSTM3();
1065   4                  }
1066   3              }
1067   2          }
1068   1      }
1069          
1070          /********************************************************
1071          POSTM3()函数
1072          仿真的时候  BPPTR=7  MAXVP=6   代入
1073          有多种情况跳 POSTPM4
1074          当BPPTR够大时  跳POSTPM31
1075          *********************************************************/
1076          void POSTM3(void)     
1077          {
1078   1          RR4=DIAXISHU;           //DIAXISHU=0x48     低压系数
1079   1      
1080   1          if(BPPTR<PA5)
1081   1          {
1082   2              POSTPM4();       
1083   2          }
1084   1          else
1085   1          {
1086   2              AA=BPPTR-PA5;
1087   2              
1088   2              if(AA<=MAXVP)           //必须在MAXVP后面 5个
1089   2              {
1090   3                  POSTPM4();
1091   3              }
1092   2              else
1093   2              {
1094   3                  NEGF=1;             //
1095   3                  POSTM31();
1096   3              } 
1097   2          }      
1098   1      }
1099          
1100          /******************************************************
1101          POSTM31()函数
1102              XX=BPPTR-PA5;
1103              AA=0x48 XX=BPPTR-PA5 代入BPCMPB()函数中
1104          *******************************************************/
1105          void POSTM31(void)        
1106          {
1107   1          XX=BPPTR-PA5;       //仿真得 XX=0X0D 
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 19  

1108   1          
1109   1          AA=RR4;             //AA=0x48
1110   1      
1111   1          BPCMPB();           //带返回 A=0 A=1 A=0xFF 三种情况         
1112   1      
1113   1          if(AA==0xFF)        //满足低压系数的情况
1114   1          {
1115   2              MAXV072=1;
1116   2              POSTM33();
1117   2          }
1118   1          else
1119   1          {
1120   2              NEGF=0;
1121   2              POSTM33();
1122   2          }
1123   1      }
1124          
1125          /**********************************************
1126          POSTM33()函数
1127          ************************************************/
1128          void POSTM33(void)         
1129          {
1130   1          PA5=PA5-1;   
1131   1          
1132   1          if(PA5)                
1133   1          {
1134   2              POSTM31();      
1135   2          }
1136   1          else
1137   1          {
1138   2              if(NEGF==0)             
1139   2              {
1140   3                  POSTPM4();
1141   3              }
1142   2              else
1143   2              {
1144   3                  DEND();              
1145   3              }
1146   2          }        
1147   1      }
1148          
1149          /*************************************************************
1150          POSTPM4()函数
1151              当 BPPTR>=BPLEN 也就是大于最大限定数之后,进行后处理 
1152              在将BPLEN 限定为64位数据后  程序走不到这边
1153          **************************************************************/
1154          void POSTPM4(void)       
1155          { 
1156   1          if(BPPTR<BPLEN)           
1157   1          {        
1158   2              POSTPMC();               
1159   2          }  
1160   1          else                      
1161   1          {
1162   2              XX=1;
1163   2              AA=0x32;                //把X=1 A=0x32代入 BPCMPB中
1164   2          
1165   2              BPCMPB();               //带返回 A=0 A=1 A=0xFF 三种情况 
1166   2          
1167   2              if(AA!=0xFF)            
1168   2              {        
1169   3                  POSTPM5();          
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 20  

1170   3              }
1171   2              else
1172   2              {
1173   3                  PA0=0;                              
1174   3                  POSTPMA();           
1175   3              }
1176   2          }        
1177   1      }    
1178          
1179          /**************************************************************
1180          POSTPM5函数
1181          ***************************************************************/
1182          void POSTPM5(void)        
1183          {
1184   1          AA=MAXVP+0x0A;  
1185   1          
1186   1          if(AA>=BPLEN)
1187   1          {
1188   2              POSTPM6();     
1189   2          }
1190   1          else
1191   1          {
1192   2              PA0=BPLEN-8;  
1193   2              POSTPMB();        
1194   2          } 
1195   1      }
1196          
1197          /**************************************************************
1198          POSTPM6函数
1199          ***************************************************************/
1200          void POSTPM6(void)     
1201          {
1202   1          PA0=MAXVP>>1;
1203   1          
1204   1          POSTPMA();
1205   1      }
1206          
1207          /**************************************************************
1208          POSTPMA函数
1209          ***************************************************************/
1210          void POSTPMA(void)      
1211          {  
1212   1          MAXVP=MAXVP-1;   
1213   1      
1214   1          POSTPMB();
1215   1      }
1216          
1217          /**************************************************************
1218          POSTPMB函数
1219          ***************************************************************/
1220          void POSTPMB(void)      
1221          {  
1222   1          HL=PA0;
1223   1          
1224   1          POSTPMB1();
1225   1      }
1226              
1227          void POSTPMB1(void)
1228          {    
1229   1          BPDATAP[HL]=BPDATAP[HL+1];
1230   1          
1231   1          BPDATAV[HL]=BPDATAV[HL+1];              //2018.5.2 11:52 发现此处错误
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 21  

1232   1          
1233   1          PA0=PA0+1;
1234   1          
1235   1          if(PA0<BPLEN)
1236   1          {
1237   2              POSTPMB();
1238   2          }
1239   1          else
1240   1          {
1241   2              BPPTR=BPPTR-1;
1242   2              POSTPMC();
1243   2          }        
1244   1      }    
1245          
1246          /**************************************************************
1247          后处理结束函数
1248          OPTR+1一次 
1249          同时再进行一次JCL
1250          **************************************************************/
1251          void POSTPMC(void)        
1252          {
1253   1          OPTRINC();    
1254   1      
1255   1      //    UART_Tx_String("------It is over------");
1256   1      //    UART_Tx_String("\r\n");
1257   1          
1258   1          //这边应该结束  相当于汇编里的 再执行 JCL 一次          
1259   1      }
1260          
1261          
1262          
1263          /**************************************************************
1264          //;*=======检测?程结束==============
1265          检测结束 打开放气阀 进行血压计算
1266          
1267          *****************************************************************/
1268          void DEND(void)    
1269          {    
1270   1          uint8 i;
1271   1          
1272   1          UART_Tx_String("\r\n");
1273   1          UART_Tx_String("BPDATAV:");
1274   1          UART_Tx_String("\r\n");
1275   1          for(i=0;i<BPPTR;i++)
1276   1          {
1277   2              UART_Tx_Data3x(BPDATAV[i]);
1278   2          }
1279   1          
1280   1          UART_Tx_String("BPDATAP:");
1281   1          UART_Tx_String("\r\n");
1282   1          for(i=0;i<BPPTR;i++)
1283   1          {
1284   2              UART_Tx_Data3x(BPDATAP[i]);
1285   2          }
1286   1          
1287   1          JC_Off_Flag=1;          //检测结束
1288   1          
1289   1      }
1290          
1291          /************************************************************************
1292          2018.01.12 08:15 将计算程序 分开封装
1293          ************************************************************************/
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 22  

1294          void CALA_BP(void)
1295          {
1296   1          CALA();             //计算血压
1297   1          
1298   1          CALHR();            //算心率函数  
1299   1          
1300   1      //    CALHRA();               //计算心率不齐
1301   1      }
1302          
1303          
1304          /**************************************************************
1305          计算收缩压
1306              PA0=50%的最大幅值 代入 CALSYS中
1307          ***************************************************************/
1308          void CALA(void)  
1309          {
1310   1          LDMAXV();               //取 AA=BPDATAV[MAXVP]    XX=MAXVP 一次
1311   1          
1312   1          PA0=AA>>1;              //PA0=最大幅值除以2后 相当于50%的压力值找收缩压 代入 CALSYS中
1313   1           
1314   1          CALSYS();               //计算收缩压    PA0 XX代入
1315   1          
1316   1          //CALA4();              //不进行系数调整时
1317   1          
1318   1          /**************** 以下是进行系数调整 ********************/ 
1319   1          
1320   1          LDMAXV();           //取AA=BPDATAV[MAXVP]  XX=MAXVP
1321   1          
1322   1          if(SYSL>0)
1323   1          {
1324   2              if(AA>0)            //AA大于0时 才计算
1325   2              {
1326   3                  if(SYSL>=170)                       //-------- SYSL>=170 --------
1327   3                  {
1328   4                      if(AA>=117)
1329   4                      {
1330   5                          CALDIA();       //MAXV>=170  系数 0.5
1331   5                      }
1332   4                      else if((AA>=60)&&(AA<117))
1333   4                      {
1334   5                          RATIOTMP=54;    //60<=MAXV<170  系数 0.54
1335   5                          CALA7(); 
1336   5                      }
1337   4                      else if(AA<60)
1338   4                      {
1339   5                          RATIOTMP=44;    //MAXV<60  系数 0.44
1340   5                          CALA7();
1341   5                      }
1342   4                  }
1343   3                  else if((SYSL>=110)&&(SYSL<170))    //------ 110<=SYSL<170 ------
1344   3                  {
1345   4                      if(AA>=45)
1346   4                      {
1347   5                          CALDIA();       //MAXV>=45  系数 0.5
1348   5                      }
1349   4                      else if((AA>=37)&&(AA<45))
1350   4                      {
1351   5                          RATIOTMP=58;    //37<=MAXV<45  系数 0.58
1352   5                          CALA7();
1353   5                      }
1354   4                      else if(AA<37)
1355   4                      {
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 23  

1356   5                          RATIOTMP=47;    //MAXV<37  系数 0.47
1357   5                          CALA7();
1358   5                      }
1359   4                  }
1360   3                  else if((SYSL>=60)&&(SYSL<110))     //------ 60<=SYSL<110 ------
1361   3                  {
1362   4                      if(AA>=44)
1363   4                      {
1364   5                          CALDIA();       //MAXV>=44  系数 0.5
1365   5                      }
1366   4                      else
1367   4                      {
1368   5                          RATIOTMP=59;    //MAXV<44  系数 0.59
1369   5                          CALA7();
1370   5                      }
1371   4                  }
1372   3                  else if(SYSL<60)            //-------- SYSL<60 --------
1373   3                  {
1374   4                      CALDIA();           // 系数 0.5
1375   4                  }
1376   3              }
1377   2              else        //AA等于0时  报错
1378   2              {
1379   3                  CALA5();
1380   3                  UART_Tx_String("ERR_2");
1381   3                  UART_Tx_String("\r\n");
1382   3              } 
1383   2          }
1384   1          else
1385   1          {
1386   2              CALA5();
1387   2              UART_Tx_String("ERR_3");
1388   2              UART_Tx_String("\r\n");
1389   2          }
1390   1      }
1391          
1392          /***************************************************************
1393          CALA5函数
1394              应该是出错吧
1395          ****************************************************************/
1396          void CALA5(void)         
1397          {
1398   1          TZH();         
1399   1      }
1400            
1401          /***************************************************************
1402          CALA7函数
1403          ****************************************************************/
1404          void CALA7(void)       
1405          {   
1406   1          LDMAXV();               //取AA=BPDATAV[MAXVP]    XX=MAXVP    
1407   1      
1408   1          XX=AA;
1409   1          AA=RATIOTMP;
1410   1          
1411   1          PERCENT();          //AA=BPDATAV[MAXVP]*RATIOTMP%  
1412   1          
1413   1          PA0=AA;     
1414   1          
1415   1          CALSYS();           //PA0=最在幅值*系数 代入        
1416   1          
1417   1          CALDIA();
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 24  

1418   1      }
1419                    
1420          /***************************************************************
1421          //;*-------计算舒张压--------------
1422              算出PA0=BPDATAV[MAXVP]*RATIOTMP%
1423              得出RR4为MAXVP的值
1424          ***************************************************************/
1425          void CALDIA(void)    
1426          {    
1427   1          SYSL_VAL=SYSL+30;      //SYSL_VAL 收缩压的值+30   
1428   1          
1429   1          LDMAXV();               //取到AA=BPDATAV[MAXVP]  
1430   1      
1431   1          XX=0x48;                //XX=72   这个是 舒张压的比例系数
1432   1          
1433   1          PERCENT();              //得出 AA=BPDATAV[MAXVP]*72%
1434   1          
1435   1          PA0=AA;                 //PA0得出  BPDATAV[MAXVP]*72%  
1436   1          
1437   1          RR4=MAXVP;       
1438   1           
1439   1          CALDIA1();              
1440   1      }
1441           
1442          /***************************************************************
1443          CALDIA1 函数
1444              算出PA0=BPDATAV[MAXVP]*72%
1445              得出RR4为MAXVP的值    后进入计算
1446          ***************************************************************/
1447          void CALDIA1(void)    
1448          {    
1449   1          RR4=RR4+1;              //RR4首先要加1 一次
1450   1          
1451   1          AA=RR4+2;
1452   1          
1453   1          CALDIA11();
1454   1      }
1455          
1456          void CALDIA11(void)    
1457          {
1458   1          if(AA>=BPPTR)     
1459   1          {
1460   2              CALDIA2();     
1461   2          }
1462   1          else
1463   1          {
1464   2              if(PA0<=BPDATAV[RR4])
1465   2              {
1466   3                  CALDIA1();
1467   3              }
1468   2              else
1469   2              {
1470   3                  if(PA0<BPDATAV[RR4+1])
1471   3                  {
1472   4                      CALDIA1();               
1473   4                  }
1474   3                  else
1475   3                  {
1476   4                      if(PA0<BPDATAV[RR4+2])
1477   4                      {
1478   5                          CALDIA1();
1479   5                      }
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 25  

1480   4                      else
1481   4                      {
1482   5                          CALDIA4();
1483   5                      }
1484   4                  }
1485   3              }
1486   2          }
1487   1      }
1488          
1489          /*****************************************************************
1490          CALDIA2函数
1491              当 MAXVP+3>=BPPTR 的时候 进入
1492              RR4=BPPTR-1
1493          ******************************************************************/
1494          void CALDIA2(void)       
1495          {    
1496   1          BB=3;                  
1497   1          
1498   1          RR4=BPPTR;
1499   1          
1500   1          RR4=RR4-1;          
1501   1      
1502   1          CALDIA3();
1503   1      }
1504          
1505          /*****************************************************************
1506          CALDIA3函数   
1507              RR4的值  代入其中进行计算
1508              PA0=BPDATAV[MAXVP]*72%
1509          ******************************************************************/
1510          void CALDIA3(void) 
1511          {
1512   1          HL=RR4;
1513   1          
1514   1          HL=HL-1;
1515   1          
1516   1          AA=PA0;                 //PA0=BPDATAV[MAXVP]*72%
1517   1          
1518   1          if(AA<BPDATAV[HL+1])    
1519   1          {
1520   2              CALDIA31();
1521   2          }
1522   1          else
1523   1          {
1524   2              if(AA<=BPDATAV[HL])
1525   2              {
1526   3                  CALDIA4();
1527   3              }
1528   2              else
1529   2              {
1530   3                  CALDIA31();
1531   3              }
1532   2          }
1533   1      }
1534          
1535          /*****************************************************************
1536          CALDIA31函数
1537          ******************************************************************/
1538          void CALDIA31(void)         
1539          {
1540   1          RR4=RR4-1;
1541   1          
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 26  

1542   1          if(RR4<MAXVP)
1543   1          {
1544   2              CALDIA32();
1545   2          }
1546   1          else
1547   1          {
1548   2              BB--;
1549   2              if(BB)
1550   2              {
1551   3                  CALDIA3();                
1552   3              }
1553   2              else
1554   2              {
1555   3                  CALDIA32();
1556   3              }
1557   2          }
1558   1      }
1559          
1560          /*****************************************************************
1561          CALDIA32函数
1562          ******************************************************************/
1563          void CALDIA32(void)     
1564          {
1565   1          DIAL=0; 
1566   1      
1567   1          DIAL_VAL=DIAL+30;    
1568   1      
1569   1          TZH();
1570   1          
1571   1          UART_Tx_String("ERR_4");
1572   1          UART_Tx_String("\r\n");
1573   1      }
1574          
1575          /*****************************************************************
1576          CALDIA4函数
1577          ******************************************************************/
1578          void CALDIA4(void)      
1579          {
1580   1          RR4=RR4-1;
1581   1          
1582   1          INSERT();      
1583   1          
1584   1          AA=PA0;      
1585   1          
1586   1          DIAL=AA;      
1587   1      
1588   1          DIAL_VAL=DIAL+30;      //DIAL_VAL 舒张压的值+30 
1589   1      }
1590          
1591          /*******************************************************************
1592          //;*    =======停止检测================
1593          ********************************************************************/
1594          void TZH(void)         
1595          { 
1596   1          fError_Measure=1;               //出错标志
1597   1      } 
1598          
1599                   
1600          /************************************************************
1601          //;*子程序编号: 02
1602          //;*作用:原始?据进?级缓冲======
1603          //;*入口:  无
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 27  

1604          //;*出口:  PA1:PA0为当前的测量值
1605          //;*占用变量: A,X
1606          //;*作用:  1.将OPTR所指原始?据送至?级缓冲
1607          //;*       2.并将?级缓冲的指针加1
1608          ***************************************************************/
1609          void TOBUF2(void)      
1610          {    
1611   1          BUF2[IPTR2]=LDOPTRA(0);  
1612   1          
1613   1          IPTR2++;                  
1614   1          if(IPTR2>15) IPTR2=0;   
1615   1      }
1616                    
1617          /**********************************************************
1618          //;*子程序编号: 03
1619          //;*作用:               取出BUF内的测量值=======
1620          //;*入口:  A
1621          //;*出口:  PA1:PA0=BUF[OPTR-A]
1622          //;*占用寄存器:A, XLL H
1623          //;*调用其他子程序列表:OPTRSUB
1624          ************************************************************/
1625          uint16 LDOPTRA(uint8 a)           
1626          {  
1627   1          if(OPTR<a)                 
1628   1          {
1629   2              a=OPTR+6-a;             
1630   2          }                            
1631   1          else                                 
1632   1          {                                      
1633   2              a=OPTR-a;               
1634   2          }                           
1635   1                                   
1636   1           return BUF[a];             
1637   1      }
1638          
1639          /*****************************************************************
1640          //;*子程序编号：04
1641          //;*作用:  A=OPTR-A对BUFLEN的余?
1642          //;*入口:  X
1643          //;*出口:  A,X
1644          *****************************************************************/
1645          uint8 OPTRSUB(uint8 aa)          
1646          {
1647   1          uint8 res;
1648   1          
1649   1          if(OPTR<aa)                 
1650   1          {
1651   2               res=OPTR-aa+6;          
1652   2          }                          
1653   1          else
1654   1          {                           
1655   2              res=OPTR-aa;            
1656   2          }
1657   1          return res;                            
1658   1      }
1659          
1660          /*****************************************************************
1661          //;*子程序编号：05
1662          //;*作用: OPTR自加一
1663          //;*入口变量:OPTR
1664          //;*出口变量:OPTR
1665          //;*占用寄存器:A, X，H
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 28  

1666          //;*调用其他子程序列表:OPTRSUB
1667          ******************************************************************/
1668          void OPTRINC(void)
1669          {
1670   1          OPTR++;
1671   1          if(OPTR>5) OPTR=0;
1672   1      }
1673          
1674          /******************************************************************
1675          //;*子程序编号：06
1676          //;*作用:求BUF2中?据平均值
1677          //;*入口:    无
1678          //;*出口:    PA5:PA4--平均值 *占用变量: HL,A,C,R3,R4,R5
1679          //;*作用:    1.求BUF2中?据的
1680          *******************************************************************/
1681          void CALBUF2(void)      
1682          {
1683   1          uint8 i;
1684   1      
1685   1          BUF2_VAL=0;
1686   1          
1687   1          for(i=0;i<16;i++)
1688   1          {
1689   2              BUF2_VAL=BUF2_VAL+BUF2[i];
1690   2          }
1691   1          PA5_PA4=BUF2_VAL/16;
1692   1      }
1693                    
1694          /***************************************************************
1695          //;*=======压力平台处理===========
1696          //;*入口: MAXPRE
1697          //;*出口:,A=有修改，A=0已经最大,MAXPRE
1698          //;*占用变量: A,MAXPRE
1699          //;*调用函?:  NO
1700          //;MAXPREUP:  
1701          ***************************************************************/
1702          void MAXPREUP(void)   
1703          {    
1704   1          if(MAXPRE>=MAXEND)          //当压力大于300mmHg时
1705   1          {
1706   2              MAXPRE=MAXEND;
1707   2              MAXPRE_BP=MAXEND_BP;
1708   2              
1709   2              AA=0;                   //当最大压力已经300了,还要再升 置0报错
1710   2          }
1711   1          else                        //在压力还没有升到300前,标志位置1
1712   1          {
1713   2              MAXPRE=MAXPRE+MAXSTEP;
1714   2              MAXPRE_BP=MAXPRE_BP+MAXSTEP_BP;
1715   2              
1716   2              if(MAXPRE<MAXEND)
1717   2              {
1718   3                  AA=1;
1719   3              }
1720   2              else
1721   2              {
1722   3                  MAXPRE=MAXEND;
1723   3                  MAXPRE_BP=MAXEND_BP;
1724   3                  AA=1;
1725   3              }
1726   2          }
1727   1      }           
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 29  

1728                    
1729          /********************************************************
1730          DRE()函数 求出满足3个条件的值
1731          满足条件的话： 
1732              PA0=4-PA6;
1733              AA=PA4-2;
1734          不满足条件的话：
1735              AA=0
1736          
1737          BUFCMP():
1738              当BUF[OPTR-4] < BUF[OPTR-3]+Y时, 返回 1
1739              当BUF[OPTR-4] = BUF[OPTR-3]+Y时, 返回 0
1740              当BUF[OPTR-4] > BUF[OPTR-3]+Y时, 返回 0xFF
1741          *********************************************************/
1742          void DRE(void)         
1743          {      
1744   1          PA6=4;
1745   1          PA5=0;
1746   1          PA4=0;
1747   1          
1748   1          DRE1();
1749   1      }
1750          
1751          /********************************************************
1752          以下为了配合汇编逻辑
1753          *********************************************************/
1754          void DRE1(void)
1755          {
1756   1          PA1=OPTRSUB(PA6);           //PA1=OPTR-PA6                       
1757   1          PA0=OPTRSUB(PA6-1);         //PA0=OPTR-PA6-1             
1758   1      
1759   1          AA=BUFCMP(PA1,PA0,Y);       //PA1=OPTR-4  PA0=OPTR-3 Y  代入BUFCMP中  
1760   1              
1761   1          if(PA6<4)
1762   1          {
1763   2              DRE11();
1764   2          }
1765   1          else
1766   1          {
1767   2              if(AA!=1)
1768   2              {
1769   3                  DRE3();
1770   3              }
1771   2              else
1772   2              {
1773   3                  DRE11();
1774   3              }
1775   2          }
1776   1      }
1777          
1778          void DRE11(void)
1779          {
1780   1          if(AA==0xFF)
1781   1          {
1782   2              DRE3();
1783   2          }
1784   1          else
1785   1          {
1786   2              if(AA!=1)
1787   2              {
1788   3                  DRE2();
1789   3              }
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 30  

1790   2              else
1791   2              {
1792   3                  PA4=PA4+1;
1793   3                  DRE2();
1794   3              }
1795   2          } 
1796   1      }
1797              
1798          void DRE2(void)
1799          {
1800   1          PA5=PA5+1;
1801   1          
1802   1          PA6=PA6-1;
1803   1          
1804   1          if(PA6)
1805   1          {
1806   2              DRE1();
1807   2          }
1808   1          else
1809   1          {
1810   2              DRE3();
1811   2          }
1812   1      }   
1813          
1814          void DRE3(void)
1815          {
1816   1          if(PA4>=3)
1817   1          {
1818   2              DRE5();
1819   2          }
1820   1          else
1821   1          {
1822   2              if(PA4<2)
1823   2              {
1824   3                  DRE4();
1825   3              }
1826   2              else
1827   2              {
1828   3                  if(PA5>=4)
1829   3                  {
1830   4                      DRE5();
1831   4                  }
1832   3                  else
1833   3                  {
1834   4                      DRE4();
1835   4                  }
1836   3              }
1837   2          }
1838   1      }
1839          
1840          void DRE4(void)
1841          {
1842   1          AA=0;
1843   1      }
1844          
1845          void DRE5(void)
1846          {
1847   1          AA=4-PA6;
1848   1          
1849   1          PA0=AA;
1850   1          
1851   1          AA=PA4-2;
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 31  

1852   1      }
1853              
1854          /**************************************************************
1855          算出新的VAVG  新Y
1856          **************************************************************/
1857          void ACALVAVG(void)       
1858          {
1859   1          PA1_PA0=LDOPTRA(4);         //取到当前的 PA1_PA0=BUF[OPTR-4]
1860   1          
1861   1          if(STARTP<PA1_PA0)
1862   1          {
1863   2              PA1_PA0=0;              //如果STARTP<当前BUF[OPTR-4]的话  PA1_PA0=0
1864   2          }
1865   1          else
1866   1          {
1867   2              PA1_PA0=STARTP-PA1_PA0;
1868   2          }
1869   1          
1870   1          PA2_PA1_PA0=(uint32)PA1_PA0*16;   
1871   1      
1872   1          PA4=COUNT-4;       
1873   1      
1874   1          PA2_PA1_PA0=PA2_PA1_PA0 & 0x0000FFFF;   
1875   1          
1876   1          PA1_PA0=PA2_PA1_PA0/PA4;        //R0,R1中存放了本次心跳的Y 
1877   1          
1878   1          if(BPPTR>=6)                    //若 BPPTR<=5 则不进行阈值抗干扰
1879   1          {
1880   2              ACALV3A();                  //进行阀值抗干扰
1881   2          }
1882   1          else
1883   1          {
1884   2              ACALV3();                   //不进行阀值抗干扰 跳ACALV3  
1885   2          }        
1886   1      }
1887          
1888          /**************************************************************
1889          进行阀值抗干扰时 进入ACALV3A
1890          ***************************************************************/
1891          void ACALV3A(void)         
1892          {                          
1893   1          if(VAVG>=0x4C)            
1894   1          {
1895   2              AA=0x75;  
1896   2              ACALV12();
1897   2          }
1898   1          else
1899   1          {
1900   2              if(VAVG<0x23)            
1901   2              {
1902   3                  AA=0x75;  
1903   3                  AACALV11();
1904   3              }
1905   2              else
1906   2              {
1907   3                  AA=0x2E;   
1908   3                  AACALV11();
1909   3              }
1910   2          }
1911   1      }
1912          
1913          /**************************************************************
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 32  

1914          AACALV11函数
1915          ***************************************************************/
1916          void AACALV11(void)        
1917          {
1918   1          AA=AA+VAVG;  
1919   1          
1920   1          if(AA>=PA1_PA0)           
1921   1          {
1922   2              ACALV3();      
1923   2          }
1924   1          else
1925   1          {
1926   2              ACALV2();   
1927   2          }
1928   1      }
1929          
1930          /**************************************************************
1931          AACALV12函数
1932          ***************************************************************/
1933          void ACALV12(void)        
1934          {
1935   1          PA4=0;                   
1936   1          if(BPPTR<10)         
1937   1          {
1938   2              ACALV14();      
1939   2          }
1940   1          else
1941   1          {
1942   2              if(VAVG<0x8D)           
1943   2              {
1944   3                  ACALV13();         
1945   3              }
1946   2              else
1947   2              {
1948   3                  PA4=PA4+1;
1949   3                  ACALV13();  
1950   3              }
1951   2          }        
1952   1      }
1953          
1954          /**************************************************************
1955          AACALV13函数
1956          ***************************************************************/
1957          void ACALV13(void)     
1958          {       
1959   1          PA4=PA4+1;       
1960   1          ACALV14();    
1961   1      }
1962          
1963          /**************************************************************
1964          AACALV14函数
1965          ***************************************************************/
1966          void ACALV14(void)        
1967          {   
1968   1          PA5_PA4=VAVG*VPARH[PA4];
1969   1          
1970   1          PA3_PA2=VAVG*VPARL[PA4];
1971   1          
1972   1          AX=PA1_PA0*100;
1973   1          
1974   1          if(AX<=PA3_PA2)
1975   1          {
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 33  

1976   2              ACALV2();
1977   2          }
1978   1          else
1979   1          {
1980   2              ACALV15();
1981   2          }
1982   1      }          
1983          
1984          /**************************************************************
1985          AACALV15函数
1986          ***************************************************************/
1987          void ACALV15(void)     
1988          {
1989   1          if(AX<PA5_PA4)
1990   1          {
1991   2              ACALV3();
1992   2          }
1993   1          else
1994   1          {
1995   2              ACALV2();
1996   2          }
1997   1      }
1998          
1999          /**************************************************************
2000          AACALV2函数
2001          ***************************************************************/
2002          void ACALV2(void)         
2003          {      
2004   1          AA=1;
2005   1          
2006   1          if(Y<0X03)
2007   1          {
2008   2              ACALV2S();
2009   2          }
2010   1          else
2011   1          {
2012   2              Y=Y-2;
2013   2              ACALV2S();
2014   2          }
2015   1      }
2016          
2017          /**************************************************************
2018          AACALV2S函数
2019              YBUF保存作用???
2020          ***************************************************************/
2021          void ACALV2S(void)     
2022          {
2023   1          YBUF[YPTR]=Y;
2024   1          YPTR++;
2025   1      }
2026          
2027          /**************************************************************
2028          AACALV3函数
2029          ***************************************************************/
2030          void ACALV3(void)         
2031          {
2032   1          if(PA1_PA0>255)
2033   1          {
2034   2              PA1_PA0=255;
2035   2          }
2036   1          ACALV3S();
2037   1      }
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 34  

2038          
2039          /**************************************************************
2040          AACALV3S函数
2041          ***************************************************************/
2042          void ACALV3S(void)       
2043          {
2044   1          PA1_PA0=PA1_PA0*5;
2045   1          
2046   1          AX=VAVG*3;
2047   1          
2048   1          PA1_PA0=PA1_PA0+AX;
2049   1          
2050   1          PA1_PA0=PA1_PA0/8;
2051   1          
2052   1          PA0=PA1_PA0&0xFFFF;
2053   1          
2054   1          VAVG=PA0;
2055   1          
2056   1          CALY();                 //算出新的Y
2057   1          
2058   1          YBUF[YPTR]=Y;
2059   1          YPTR++;
2060   1      }          
2061          
2062                    
2063          /*************************************************************   
2064          //;*=======斜率阈值计算=============
2065          //;*占用变量: A,X
2066          //;*?用变量: VAVG,Y
2067          //;*作用:       依据VAVG求出Y
2068          Y=VAVG/16*85/100
2069          **************************************************************/
2070          void CALY(void)          
2071          {
2072   1          if(VAVG>=8)         //VAVG必须要大于8     
2073   1          {
2074   2              if(Y<96)        //Y的值 必须小于96         
2075   2              {
2076   3                  AX=VAVG;            //例 VAVG=206                   
2077   3                                      
2078   3                  AA=AX/16;           //AA=206/16=12                         
2079   3                  CC=AX%16;           //CC=14              
2080   3                                             
2081   3                  if(CC<8)                            
2082   3                  {                         
2083   4                      AA=AA-1;                             
2084   4                  }                         
2085   3                  AX=AA*85;           //AA=12    AX=12*85                 
2086   3                                        
2087   3                  AA=AX/100;                  
2088   3                  CC=AX%100;                 
2089   3                  if(CC>49)                 
2090   3                  {                         
2091   4                      AA=AA+1;              
2092   4                  }                          
2093   3                  Y=AA;              
2094   3              }                     
2095   2              else
2096   2              {                  
2097   3                  Y=0;               
2098   3              }                    
2099   2          }                           
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 35  

2100   1          else                    //VAVG<8的话 Y=0     
2101   1          {
2102   2              Y=0;                        
2103   2          }  
2104   1      
2105   1          //--------------- 串口 VAVG -----------------//
2106   1      //    UART_Tx_String("VAVG:");
2107   1      //    UART_Tx_Data3x(VAVG); 
2108   1      //    UART_Tx_String("Y:");
2109   1      //    UART_Tx_Data3x(Y); 
2110   1          
2111   1      }                          
2112          
2113          /*******************************************************
2114          BPCMPB()函数
2115              AA XX 代入其中
2116              BPDATAV[XX]代入到LDMAXVP()中
2117              比较 BPDATAV[XX]*100 BPDATAV[MAXVP]*72
2118              相等 A=0   前者大 A=1  后者大 A=0xFF
2119          ********************************************************/
2120          void BPCMPB(void)         
2121          {
2122   1          PA2=AA;                         
2123   1          
2124   1          HL=XX;                     
2125   1          
2126   1          AA=BPDATAV[HL];           
2127   1          PA1_PA0=AA*100;          
2128   1      
2129   1          LDMAXV();                   //AA=BPDATAV[MAXVP] 
2130   1           
2131   1          PA3_PA2=AA*PA2;          
2132   1      
2133   1          if(PA1_PA0==PA3_PA2)
2134   1          {
2135   2              AA=0;
2136   2          }
2137   1          else if(PA1_PA0<PA3_PA2)
2138   1          {
2139   2              AA=0xFF;
2140   2          }
2141   1          else
2142   1          {
2143   2              AA=1;
2144   2          }
2145   1          
2146   1      }   
2147          
2148          /*******************************************************
2149          当BUF[OPTR-4] < BUF[OPTR-3]+Y时, 返回 1
2150          当BUF[OPTR-4] = BUF[OPTR-3]+Y时, 返回 0
2151          当BUF[OPTR-4] > BUF[OPTR-3]+Y时, 返回 0xFF
2152          *******************************************************/
2153          uint8 BUFCMP(uint8 a1,uint8 a0,uint8 yy)    
2154          {
2155   1          uint8 res;
2156   1          
2157   1          PA3_PA2=BUF[a1];            //PA3取到BUF[OPTR-4]
2158   1          PA1_PA0=BUF[a0]+yy;         //PA2取到BUF[OPTR-3]+Y
2159   1          
2160   1          if(PA3_PA2==PA1_PA0)
2161   1          {
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 36  

2162   2              res=0;
2163   2          }
2164   1          else if(PA3_PA2<PA1_PA0)
2165   1          {
2166   2              res=1;
2167   2          }
2168   1          else    
2169   1          {
2170   2              res=0xFF;
2171   2          }    
2172   1          
2173   1          return res;
2174   1      }
2175          
2176          /***************************************************************
2177          DPEAK函数
2178          当前的BUF[OPTR]+(COUNT-COUNT1)*Y  去跟PEAKP去比
2179          比PEAKP小的话 返回0 同时 COUNT会+1一次  COUNT1不变
2180          如果比PEAKP大的话 会让COUNT1=COUNT  PEAKP=当前BUF[OPTR]
2181          COUNT<17时 一直返回0  只有当COUNT=17的时候 COUNT-COUNT1>=6 才返回1
2182          **************************************************************/
2183          uint8 DPEAK(void)       
2184          {    
2185   1          uint8 res;
2186   1          
2187   1          PA3_PA2=LDOPTRA(0);                     //PA3_PA2取到 BUF[OPTR]的值        
2188   1          
2189   1          PA1_PA0=PA3_PA2+(COUNT-COUNT1)*Y;       //BUF[OPTR]+(COUNT-COUNT1)*Y
2190   1          
2191   1          if(PA1_PA0<PEAKP)
2192   1          {
2193   2              if(COUNT<17)
2194   2              {
2195   3                  res=0;
2196   3              }
2197   2              else
2198   2              {
2199   3                  if(COUNT-COUNT1>=6)
2200   3                  {
2201   4                      res=1;
2202   4                  }
2203   3                  else
2204   3                  {
2205   4                      res=0;
2206   4                  }
2207   3              }
2208   2          }
2209   1          else
2210   1          {
2211   2              COUNT1=COUNT;
2212   2              PEAKP=PA3_PA2;
2213   2              
2214   2              if(COUNT<17)
2215   2              {
2216   3                  res=0;
2217   3              }
2218   2              else
2219   2              {
2220   3                  if(COUNT-COUNT1>=6)
2221   3                  {
2222   4                      res=1;
2223   4                  }
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 37  

2224   3                  else
2225   3                  {
2226   4                      res=0;
2227   4                  }
2228   3              }
2229   2          }
2230   1          
2231   1          return res;
2232   1      }
2233          
2234          /******************************************************************
2235          两个数 相减的绝对值
2236          返回值 res
2237          ******************************************************************/
2238          uint8 ABS_8data(uint8 DATA_A,uint8 DATA_B)
2239          {
2240   1          uint8 res;
2241   1          
2242   1          if(DATA_A>=DATA_B)
2243   1          {
2244   2              res=DATA_A-DATA_B;
2245   2          }
2246   1          else
2247   1          {
2248   2              res=DATA_B-DATA_A;
2249   2          }
2250   1          return res;
2251   1      }
2252            
2253          /******************************************************************
2254          CALHR 计算心率函数
2255          ******************************************************************/
2256          void CALHR(void)   
2257          {       
2258   1          uint8 i;
2259   1          
2260   1          MAXH=5;      
2261   1          
2262   1          if(BPTR_Temp>=32)       //2018.5.10 改  BPTR_Temp不受BPLEN 控制   问题解决
2263   1          {
2264   2              BPTR=32;         //BPTR在上升沿检出的时候 会加1一次          
2265   2          }
2266   1          
2267   1          if(BPTR_Temp==0)           //当它为0的时候,就跳出错
2268   1          {
2269   2              TZH();
2270   2          }
2271   1          else
2272   1          {
2273   2              MAXVP=BPTR_Temp-2;
2274   2              
2275   2      //        UART_Tx_String("\r\n");             //======串口传输======
2276   2      //        UART_Tx_String("BPTR:");
2277   2      //        UART_Tx_Data3x(BPTR); 
2278   2      //        UART_Tx_String("BPTR_Temp:");
2279   2      //        UART_Tx_Data3x(BPTR_Temp);           
2280   2      
2281   2              
2282   2      //        UART_Tx_String("HRBUF[]:");         //======串口传输======
2283   2      //        UART_Tx_String("\r\n");
2284   2              
2285   2              do
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 38  

2286   2              {
2287   3                  for(i=0;i<BPTR;i++)
2288   3                  {
2289   4                      HRBUF1[i]=HRBUF[i];         //全部转移到HRBUF1[]中     
2290   4                      
2291   4      //                UART_Tx_Data3x(HRBUF[i]);       //----------- 传输出 心率间隔 ------------//
2292   4                  }
2293   3      
2294   3                  HL=0;           //HL对应HRBUF1
2295   3                  DE=0;           //DE对应HRBUF1         
2296   3                  BB=0;          
2297   3      
2298   3                  for(DE=0;DE<BPLEN;DE++)
2299   3                  {
2300   4                      PA0=0;
2301   4                      
2302   4                      for(BB=0;BB<BPLEN;BB++)
2303   4                      {
2304   5                          AA=ABS_8data(HRBUF1[DE],HRBUF1[BB]);
2305   5                          
2306   5                          if(AA<MAXH)
2307   5                          {
2308   6                              PA0=PA0+2;
2309   6                              if(PA0>=BPTR)
2310   6                              {
2311   7                                  break;
2312   7                              }
2313   6                              if(BB>=BPTR)
2314   6                              {
2315   7                                  HRBUF1[DE]=0;
2316   7                                  break;
2317   7                              }
2318   6                          }
2319   5                          else
2320   5                          {
2321   6                              if(PA0>=BPTR)
2322   6                              {
2323   7                                  break;
2324   7                              }
2325   6                              if(BB>=BPTR)
2326   6                              {
2327   7                                  HRBUF1[DE]=0;
2328   7                                  break;
2329   7                              }
2330   6                          }
2331   5                      }
2332   4                  }
2333   3      
2334   3                  BATEN=0;           //对应的MOVW BATENL,AX
2335   3      
2336   3                  PA4=0;   
2337   3                  
2338   3      //            UART_Tx_String("HRBUF1[]:");            //======串口传输======
2339   3      //            UART_Tx_String("\r\n");
2340   3                  
2341   3                  for(i=0;i<BPTR;i++)
2342   3                  {
2343   4                      if(HRBUF1[i]>0)
2344   4                      {
2345   5                          PA4++;
2346   5                      }
2347   4                      BATEN=BATEN+HRBUF1[i];
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 39  

2348   4                      
2349   4      //                UART_Tx_Data3x(HRBUF1[i]);       //----------- 传输出 处理过的心率间隔 ------------//
2350   4                  }
2351   3                  
2352   3                  if(PA4>=4)
2353   3                  {
2354   4                      HRERR=0;
2355   4                  }
2356   3                  else
2357   3                  {
2358   4                      MAXH=MAXH+1;
2359   4                      HRERR=1;
2360   4                      
2361   4                      UART_Tx_String("MAXH:");
2362   4                      UART_Tx_Data3x(MAXH); 
2363   4                      
2364   4                      if(MAXH>30)
2365   4                      {
2366   5                          TZH();
2367   5                          HRERR=0;            //2018.5.2 11:50 发现此处错误 
2368   5                          
2369   5                          UART_Tx_String("ERR_5");
2370   5                          UART_Tx_String("\r\n");
2371   5                      }
2372   4                  }
2373   3              }
2374   2              while(HRERR);
2375   2              
2376   2              if(fError_Measure==0)       //不出错就跳转   2018.5.10 新增 
2377   2              {
2378   3                  DATACH9();
2379   3              }
2380   2          }
2381   1      }             
2382          
2383          /******************************************************************
2384          DATACH9
2385          ******************************************************************/
2386          void DATACH9(void)    
2387          {      
2388   1      //    PA1_PA0=0x0BB8;         //PA1_PA0=3000
2389   1          PA1_PA0=3000;
2390   1          
2391   1          PA2=PA4;                                //PA2为 HRBUF1[]的有效值 个数 
2392   1          
2393   1          PA2_PA1_PA0=(uint32)PA1_PA0*PA2;        //PA1_PA0=3000   PA2_PA1_PA0=3000*18  =0xD2F0 54000
2394   1          
2395   1          PA5_PA4=BATEN;                          //PA5_PA4 所有心率间隔的总和  
2396   1          
2397   1          //----------- 传输出 心率有效数及和 ------------//
2398   1      //    UART_Tx_String("num:");
2399   1      //    UART_Tx_Data3x(PA2);
2400   1      //    UART_Tx_String("BATEN:");
2401   1      //    UART_Tx_Data5x(BATEN);
2402   1          
2403   1          PA2_PA1_PA0=PA2_PA1_PA0 & 0x00FFFFFF;   //PA3=0
2404   1          
2405   1          PA1_PA0=PA2_PA1_PA0/PA5_PA4;            //
2406   1          
2407   1          PA1=PA1_PA0>>8;
2408   1          PA0=PA1_PA0&0xFF;
2409   1      
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 40  

2410   1          PHR=PA1_PA0;                       
2411   1      
2412   1          PHR_VAL=PHR;
2413   1      }           
2414          
2415          /******************************************************************
2416          CALHRA
2417              开始计算心率函数
2418          ******************************************************************
2419          void CALHRA(void)      
2420          {
2421              AX=3000/PHR;            //以60心率计 先用3000/心率  算出平均心率间隔是50
2422              
2423              BATEN=AX*25/100;        //  50*25/100=12.5  也就是25%
2424              
2425              PA4=0;
2426              
2427              CALIHB();   
2428              
2429          } 
2430          */
2431                             
2432          /******************************************************************                      
2433          计算心率标准间隔
2434          ******************************************************************
2435          void CALIHB(void)     
2436          {
2437              BB=1;
2438              HL=0;
2439              
2440              CALIHB1();
2441          }
2442          */
2443          
2444          /*****************************************************************
2445          
2446          *****************************************************************
2447          void CALIHB1(void)
2448          {
2449              if(HRBUF[HL+1]>=BATEN)
2450              {
2451                  AA=HRBUF[HL+1]-BATEN;
2452                  
2453                  if(HRBUF[HL]>=BATEN)
2454                  {
2455                      AA=HRBUF[HL]-BATEN;
2456                  }
2457                  else
2458                  {
2459                      AA=BATEN-HRBUF[HL];
2460                  }
2461                  
2462                  if(AA>=3)
2463                  {
2464                      CALIHB5();
2465                  }
2466                  else
2467                  {
2468                      if(HRBUF[HL+2]>=BATEN)
2469                      {
2470                          AA=HRBUF[HL+2]-BATEN;
2471                      }
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 41  

2472                      else
2473                      {
2474                          AA=BATEN-HRBUF[HL+2];
2475                      }
2476                      if(AA>=3)
2477                      {
2478                          CALIHB5();
2479                      }
2480                      else
2481                      {
2482                          PA4=PA4+1;
2483                          CALIHB5();
2484                      }
2485                  }
2486              }
2487              else
2488              {
2489                  AA=BATEN-HRBUF[HL+1];
2490                  
2491                  CALIHB5();
2492              }
2493          }
2494          */
2495                
2496          /*************************************************************
2497          
2498          ***************************************************************
2499          void CALIHB5(void)      
2500          {
2501              HL=HL+1;             
2502              BB=BB+1;              
2503              AA=BB;              
2504              
2505              if(AA!=MAXVP)
2506              {
2507                  CALIHB1();
2508              }
2509              else
2510              {
2511                  if(PA4>=2)
2512                  {
2513                      IHB=1;
2514                      
2515                      //======串口传输======
2516                      UART_Tx_String("IHB=1");
2517                      UART_Tx_String("\r\n");
2518                  }
2519                  else
2520                  {
2521                      IHB=0;
2522                      
2523                      //======串口传输======
2524                      UART_Tx_String("IHB=0");
2525                      UART_Tx_String("\r\n");
2526                  }
2527              } 
2528          }
2529          */
2530                    
2531          /**************************************************************
2532          TOBP函数
2533          BPDATAP[BPPTR] 存 上升沿起始压力值-30的值
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 42  

2534          BPDATAV[BPPTR] 存  PEAKP右移2位的值
2535          后面比较 BPDATAP[BPPTR] BPDATAP[BPPTR-1] 的大小
2536          如果 BPDATAP[BPPTR] >= BPDATAP[BPPTR-1] 的话 BPPTR减1一次
2537          直到 BPDATAP[BPPTR] < BPDATAP[BPPTR-1] 直接返回
2538          ***************************************************************/
2539          void TOBP(void)  
2540          {    
2541   1          PA2_PA1_PA0=(uint32)STARTP*100;
2542   1          
2543   1          PA2_PA1_PA0=PA2_PA1_PA0 & 0x00FFFFFF;   
2544   1          
2545   1          PA1_PA0=PA2_PA1_PA0/BASEDT_VAL;       //PA1_PA0=STARTP*100/8000
2546   1          //这边验证 正确   PA1_PA0 当前 上升沿的STARTP的值
2547   1      
2548   1          if(PA1_PA0<30)
2549   1          {
2550   2              PA1_PA0=30;
2551   2          }
2552   1          
2553   1          AX=PA1_PA0-30;      //这边要减去30   应该是所谓的压力值 减30的说法吧
2554   1          
2555   1          if(AX>=255)
2556   1          {
2557   2              AX=255;
2558   2          }
2559   1          
2560   1          PA2=AX;
2561   1          
2562   1          BPDATAP[BPPTR]=PA2;         //BPDATAP[BPPTR] 存 上升沿起始压力值-30的值
2563   1          
2564   1          PEAKP=PEAKP>>2;             //PEAKP要往右移2位
2565   1          
2566   1          BPDATAV[BPPTR]=PEAKP;       //BPDATAV[BPPTR] 存  PEAKP右移2位的值
2567   1          
2568   1          UART_Tx_String("BPPTR:");
2569   1          UART_Tx_Data3x(BPPTR); 
2570   1          UART_Tx_String("BPMAXV:");
2571   1          UART_Tx_Data3x(PEAKP); 
2572   1          UART_Tx_String("BPMAXP:");
2573   1          UART_Tx_Data3x(PA2); 
2574   1          
2575   1          TOBP1();
2576   1      }
2577            
2578          void TOBP1(void)
2579          {
2580   1          if(BPPTR)
2581   1          {
2582   2              for(BPPTR;BPPTR>0;BPPTR--)
2583   2              {
2584   3                  if(BPDATAP[BPPTR]>=BPDATAP[BPPTR-1])
2585   3                  {
2586   4                      BPDATAP[BPPTR-1]=BPDATAP[BPPTR];
2587   4                  }
2588   3                  else
2589   3                  {
2590   4                      break;
2591   4                  }
2592   3              }
2593   2          }
2594   1      }     
2595          
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 43  

2596          /************************************************************
2597          LDMAXV()函数
2598              AA=BPDATAV[MAXVP]
2599              AA取到 MAXVP的最大压值
2600          *************************************************************/
2601          void LDMAXV(void)        
2602          {
2603   1          AA=BPDATAV[MAXVP];    
2604   1          XX=MAXVP;
2605   1      }
2606          
2607          /***********************************************************
2608          CALPEAK函数
2609          重新定义了一下PEAKP的值
2610              根据这一次的上升沿 算出来上一次的峰值  PEAKP 
2611              然后在下面的TOBP中,保存在BPDATAV[]里 
2612              POSTP3 里再得新 得出PEAKP
2613          ***********************************************************/
2614          void CALPEAK(void)      
2615          {           
2616   1          PA1_PA0=LDOPTRA(4);         //先取PA1_PA0=BUF[OPTR-4] 
2617   1      
2618   1          //--------------- 串口传出 STARTP信息 -----------------//
2619   1      //    UART_Tx_String("STARTP0:");
2620   1      //    UART_Tx_Data5x(STARTP); 
2621   1      //    UART_Tx_String("STARTP1:");
2622   1      //    UART_Tx_Data5x(PA1_PA0);    
2623   1          
2624   1          PA1_PA0=STARTP-PA1_PA0;     //再让STARTP-BUF[OPTR-4] 这个STARTP应该是上一个的STARTP的值
2625   1      
2626   1          PA2_PA1_PA0=(uint32)PA1_PA0*COUNT1;  
2627   1        
2628   1          PA2_PA1_PA0=PA2_PA1_PA0 & 0x00FFFFFF;   
2629   1      
2630   1          PA1_PA0=PA2_PA1_PA0/(COUNT-4);          //上面的值 / BUF[OPTR-4]与STARTP相隔的数量
2631   1      
2632   1          PA3_PA2=PA1_PA0+PEAKP;                  //PA3_PA2=再加上 上面的PEAKP
2633   1          
2634   1              
2635   1          //--------------- 串口传出 COUNT 信息 -----------------//
2636   1      //    UART_Tx_String("COUNT1:");
2637   1      //    UART_Tx_Data3x(COUNT1); 
2638   1      //    UART_Tx_String("COUNT-4:");
2639   1      //    UART_Tx_Data3x(COUNT-4);
2640   1      //    UART_Tx_String("PEAKP0:");
2641   1      //    UART_Tx_Data5x(PEAKP);
2642   1      
2643   1      
2644   1          if(PA3_PA2<STARTP)
2645   1          {
2646   2              PEAKP=0;
2647   2          }
2648   1          else
2649   1          {
2650   2              PEAKP=PA3_PA2-STARTP;       //PEAKP的值 重新定义
2651   2          }   
2652   1          
2653   1          UART_Tx_String("PEAKP:");
2654   1          UART_Tx_Data5x(PEAKP);
2655   1      }
2656          
2657          /****************************************************************
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 44  

2658          INSERT函数 
2659              判断 BPDATAV[RR4]与BPDATAV[RR4+1]的大小
2660              进入之前 RR4代入
2661              PA0是BPDATAV[MAXVP]的50%
2662          2018.01.10 10:35 仿真 将AA=32  BPDATAV[3]=23  RR4=6 代入
2663              
2664              BPDATAV[RR4] 正好是满<BPDATAV[MAXVP]的50%的那个数
2665              如果 BPDATAV[RR4]=BPDATAV[RR4+1] 取BPDATAP[RR4]=BPDATAP[RR4+1]的平均数
2666              如果 BPDATAV[RR4]>BPDATAV[RR4+1]
2667          
2668          *****************************************************************/
2669          void INSERT(void)       
2670          {  
2671   1          HL=RR4;                  
2672   1          AA=BPDATAV[HL];                 //求出正好满足<BPDATAV[MAXVP]/2的数
2673   1          PA1=AA;               
2674   1          
2675   1          if(AA==BPDATAV[HL+1])           //
2676   1          {
2677   2              AA=AA-BPDATAV[HL+1];
2678   2              INSERT4();                  //当BPDATAV[RR4]=BPDATAV[RR4+1] 跳INSERT4
2679   2          }
2680   1          else if(AA>BPDATAV[HL+1])       //
2681   1          {
2682   2              AA=AA-BPDATAV[HL+1];
2683   2              INSERT1();
2684   2          }
2685   1          else                            //BPDATAV[RR4]<BPDATAV[RR4+1] 的情况
2686   1          {
2687   2              AA=BPDATAV[HL+1]-AA;        //仿真得 AA=35-23
2688   2              INSERT1();
2689   2          }
2690   1      }
2691          
2692          /********************************************************************
2693          INSERT1函数
2694              比较PA0与PA1的大小  取差值后进入 INSERT2
2695          *********************************************************************/
2696          void INSERT1(void)       
2697          {      
2698   1          RR5=AA;                 //RR5=上面的AA
2699   1          
2700   1          if(PA0>=PA1)          
2701   1          {
2702   2              AA=PA0-PA1;         //AA=9
2703   2              INSERT2();          
2704   2          }
2705   1          else
2706   1          {
2707   2              AA=PA1-PA0;
2708   2              INSERT2();
2709   2          }
2710   1      }
2711          
2712          /********************************************************************
2713          INSERT2函数
2714              比较 BPDATAP[HL]与BPDATAP[HL+1]的值   比较的压力值
2715          2018.01.10 10:43 代入仿真计算
2716          *********************************************************************/
2717          void INSERT2(void)     
2718          {      
2719   1          PA2=AA;             //PA2=|PA0-PA1|  绝对值  
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 45  

2720   1      
2721   1          HL=RR4;             //HL=6
2722   1          
2723   1          AA=BPDATAP[HL];     //AA=BPDATAP[6]=93
2724   1          
2725   1          PA6=AA;             //PA6=BPDATAP[HL] 
2726   1          
2727   1          SBFLAG=0;         
2728   1          
2729   1          if(AA>=BPDATAP[HL+1])          
2730   1          {
2731   2              AA=AA-BPDATAP[HL+1];        //AA=6   
2732   2              INSERT3();                  //将AA的值 代入INSERT3
2733   2          }
2734   1          else
2735   1          {
2736   2              AA=BPDATAP[HL+1]-AA;
2737   2              SBFLAG=1;                   //当AA<BPDATAP[HL+1]时, SBFLAG要置1
2738   2              INSERT3();
2739   2          }
2740   1      }
2741          
2742          /********************************************************************
2743          INSERT3函数
2744          
2745          *********************************************************************/
2746          void INSERT3(void)          
2747          {
2748   1          PA0=AA;         //PA0=| BPDATAP[HL]-BPDATAP[HL+1] | 取绝对值 
2749   1          
2750   1          PA1_PA0=PA2*PA0;            //PA2=9  PA1_PA0=54
2751   1          
2752   1          PA4=RR5;                    // BPDATAV[RR4+1]-BPDATAV[RR4]
2753   1          
2754   1          PA1_PA0=PA1_PA0/PA4;      
2755   1          
2756   1          AA=PA6;                   
2757   1          
2758   1          if(SBFLAG==0) 
2759   1          {
2760   2              PA0=AA-PA1_PA0;
2761   2          }
2762   1          else
2763   1          {
2764   2              PA0=AA+PA1_PA0;         //PA0=93+4
2765   2          }
2766   1      }    
2767                
2768          /********************************************************************
2769          INSERT4函数
2770          
2771          *********************************************************************/      
2772          void INSERT4(void)         
2773          {  
2774   1          HL=RR4;
2775   1          
2776   1          AA=BPDATAP[HL]+BPDATAP[HL+1];
2777   1          
2778   1          AA=AA>>1;
2779   1          
2780   1          PA0=AA;
2781   1      }
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 46  

2782          
2783          /****************************************************************
2784          //;========求A的X%->R0=======
2785          //;*  函?名：PERCENT
2786          //;*  函?功能: 求A的X%
2787          //;*  函?入口变量:A，X
2788          //;*  函?出口变量:R0
2789          //;*  调用?程中所用寄存器:A, X，H，R0~R5
2790          //;*  调用其他函?列表:UDIV
2791          //;*  调用函?列表:no
2792          //;*  其他:
2793          ****************************************************************/
2794          void PERCENT(void)      
2795          { 
2796   1          AX=AA*XX;  
2797   1          
2798   1          CC=AX%100;
2799   1          AX=AX/100;
2800   1          
2801   1          XX=AX%256;
2802   1          
2803   1          if(CC<50)
2804   1          {
2805   2              AA=XX;
2806   2          }
2807   1          else
2808   1          {
2809   2              AA=XX+1;
2810   2          }
2811   1      }
2812            
2813          /**************************************************************
2814          DMPEAK()函数
2815          在BPPTR=0的时候  直接返回
2816          PA0=BPDATAV[0]
2817          
2818          MAXVP 求出最高点的峰值点
2819          **************************************************************/
2820          void DMPEAK(void)     
2821          {
2822   1          MAXVP=0;             
2823   1          PA0=0;                  
2824   1          CC=0;
2825   1      
2826   1          DMPEAK1();
2827   1      }    
2828          
2829          void DMPEAK1(void)
2830          {
2831   1          HL=CC;
2832   1          
2833   1          AA=BPDATAV[HL];
2834   1          
2835   1          DMPEAK11();
2836   1      }
2837           
2838          void DMPEAK11(void)
2839          {
2840   1          if(AA<PA0)
2841   1          {
2842   2              CC=CC+1;
2843   2              if(CC<BPPTR)
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 47  

2844   2              {
2845   3                  DMPEAK1();
2846   3              }
2847   2              else
2848   2              {
2849   3                  DMPEAK2();
2850   3              }
2851   2          }
2852   1          else
2853   1          {
2854   2              PA0=AA;
2855   2              
2856   2              MAXVP=CC;
2857   2              
2858   2              CC=CC+1;
2859   2              if(CC<BPPTR)
2860   2              {
2861   3                  DMPEAK1();
2862   3              }
2863   2              else
2864   2              {
2865   3                  DMPEAK2();
2866   3              }
2867   2          }
2868   1      }
2869          
2870          /**************************************************************
2871          DMPEAK2()函数
2872          **************************************************************/
2873          void DMPEAK2(void)
2874          {
2875   1      
2876   1      }
2877          
2878          /**************************************************************
2879          ENOISE函数
2880              比较 BPDATAV[BPPTR-1] BPDATAV[BPPTR-2] BPDATAV[BPPTR-3] 的大小
2881          ***************************************************************/
2882          void ENOISE(void)         
2883          {
2884   1          if(BPPTR<3)
2885   1          {
2886   2              ENOISE3();              //小于3的时候  不用作比较 直接跳返回
2887   2          }
2888   1          else
2889   1          {
2890   2              HL=BPPTR-3;
2891   2              
2892   2              PA0=BPDATAV[HL+2];    
2893   2              PA1=BPDATAV[HL+1];  
2894   2              PA2=BPDATAV[HL];       
2895   2              
2896   2              if(PA1==PA0)
2897   2              {
2898   3                  ENOISE3();
2899   3              }
2900   2              else if(PA1<PA0)        //PA1<PA0
2901   2              {
2902   3                  ENOISE1();
2903   3              }
2904   2              else
2905   2              {
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 48  

2906   3                  if(PA1<=PA2)
2907   3                  {
2908   4                      ENOISE3();
2909   4                  }
2910   3                  else                    //PA1>PA0 且 PA1>PA2  中间最大
2911   3                  {
2912   4                      AA=PA0+PA2;
2913   4                      PA3=AA;
2914   4                      PA0=AA>>2;
2915   4                      
2916   4                      AA=PA3-PA0;
2917   4                      
2918   4                      if(AA>=PA1)
2919   4                      {
2920   5                          ENOISE3();
2921   5                      }
2922   4                      else
2923   4                      {
2924   5                          ENOISE2();      //如果中间的值大于 前后两个和的3/4 跳ENOISE2
2925   5                      }
2926   4                  }
2927   3              }
2928   2          }
2929   1      }
2930          
2931          /*********************************************************
2932          ENOISE2函数
2933          *********************************************************/
2934          void ENOISE2(void)            
2935          {
2936   1          BPDATAV[HL+1]=BPDATAV[HL+2];
2937   1          
2938   1          HL=BPPTR-3;
2939   1          
2940   1          BPDATAP[HL+1]=BPDATAP[HL+2];
2941   1          
2942   1          BPPTR--;
2943   1          
2944   1          ENOISE3();
2945   1      }
2946          
2947          /*********************************************************
2948          ENOISE1函数
2949          *********************************************************/
2950          void ENOISE1(void)          
2951          {
2952   1          if(PA1>=PA2)
2953   1          {
2954   2              ENOISE3();
2955   2          }
2956   1          else                //PA1<PA2   PA1<PA0   中间最小
2957   1          {
2958   2              AA=PA2+PA0;
2959   2              
2960   2              AA=AA>>2;       
2961   2              
2962   2              if(AA<=PA1)
2963   2              {
2964   3                  ENOISE3();
2965   3              }
2966   2              else        //中间的值还小于首尾的1/4 进ENOISE2
2967   2              {
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 49  

2968   3                  ENOISE2();
2969   3              }
2970   2          }
2971   1      }
2972          
2973          /*********************************************************
2974          ENOISE3函数
2975              空语句   用来作跳转逻辑用
2976          *********************************************************/
2977          void ENOISE3(void)
2978          {
2979   1          
2980   1      }
2981          
2982          /*****************************************************************
2983          CALSYS函数
2984              PA0=50%的最大幅值 代入 CALSYS中
2985              计算条件 MAXVP>1
2986          *******************************************************************/
2987          void CALSYS(void)    
2988          {
2989   1          RR4=MAXVP;              //取到MAXVP的值
2990   1          
2991   1          if(MAXVP<2)             //不能找到收缩压  直接SYSL=0       
2992   1          {
2993   2              CALSYS4();          //收缩压计算的前提1：MAXVP>1  否则压力为0
2994   2          }
2995   1          else
2996   1          {
2997   2              CALSYS0();          //MAXVP>=2时 进入到收缩压计算  
2998   2          }
2999   1      }
3000           
3001          /*****************************************************************
3002          CALSYS0函数
3003              当MAXVP>=2时 进入到收缩压计算
3004              PA0=50%的最大幅值 
3005          *******************************************************************/
3006          void CALSYS0(void)
3007          {  
3008   1          RR4=RR4-1;          //让RR4=MAXVP-1   
3009   1          
3010   1          if(RR4<4)       
3011   1          {
3012   2              CALSYS1();      //如果RR4<4的话 也就是MAXVP<5 跳 CALSYS1
3013   2          }
3014   1          else
3015   1          {
3016   2              HL=RR4-3;       //
3017   2              
3018   2              AA=PA0;         //AA取到PA0  也就是 BPDATAV[MAXVP]/2
3019   2              
3020   2              AA=AA+1;        //当时是 PEAKP的值>>2次的值  所以会比较小 要加1  
3021   2              
3022   2              CALSYS01();     //跳转去判断
3023   2          }
3024   1      }
3025          
3026          /*****************************************************************
3027          CALSYS01函数
3028              比较 BPDATAV[MAXVP]往前 连续3个 小于50%的
3029          *******************************************************************/
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 50  

3030          void CALSYS01(void)
3031          {    
3032   1          if(AA<BPDATAV[HL+3])        //MAXVP的前一个            
3033   1          {
3034   2              CALSYS0();              //小于再往下跳    
3035   2          }
3036   1          else
3037   1          {
3038   2              if(AA<BPDATAV[HL+2])
3039   2              {
3040   3                  CALSYS0();
3041   3              }
3042   2              else
3043   2              {
3044   3                  if(AA<BPDATAV[HL+1])
3045   3                  {
3046   4                      CALSYS0();
3047   4                  }
3048   3                  else
3049   3                  {
3050   4                      if(AA<BPDATAV[HL])      //满足3个条件后 仿真得 AA=32  BPDATAV[3]=23  RR4=6  
3051   4                      {
3052   5                          CALSYS0();          //BPDATAV[X],[X-1],[X-2],[X-3]<PA0 进入CALSYS5
3053   5                      }
3054   4                      else
3055   4                      {
3056   5                          CALSYS5();          //直接转入高压插值
3057   5                      }
3058   4                  }
3059   3              }
3060   2          }
3061   1      }          
3062            
3063          /******************************************************************
3064          CALSYS1 函数
3065              RR4<4的情况下  令RR4=0
3066              从零点开始到3,依次将数据与PA0进行比较
3067          ********************************************************************/
3068          void CALSYS1(void)       
3069          {   
3070   1          RR4=0;                  //从零点开始到3,依次将数据与PA0进行比较
3071   1          
3072   1          CALSYS2();
3073   1      }          
3074                
3075          /******************************************************************
3076          CALSYS2 函数
3077          只有当PA0<=BPDATAV[RR4+1]的时候 跳CALSYS5
3078          其余转CALSYS3
3079          ******************************************************************/
3080          void CALSYS2(void)       
3081          {
3082   1          AA=PA0;                 //AA取到PA0
3083   1          
3084   1          HL=RR4;
3085   1          
3086   1          if(AA<BPDATAV[HL])
3087   1          {
3088   2              CALSYS3();          //PA0<BPDATAV[RR4]时 跳CALSYS3
3089   2          }
3090   1          else
3091   1          {
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 51  

3092   2              if(AA<=BPDATAV[HL+1])
3093   2              {
3094   3                  CALSYS5();      //只有当PA0<=BPDATAV[RR4+1]的时候 跳CALSYS5
3095   3              }
3096   2              else
3097   2              {
3098   3                  CALSYS3();      //跳CALSYS3    
3099   3              }
3100   2          }        
3101   1      }          
3102            
3103          /******************************************************************
3104          CALSYS3 函数
3105              RR4在加1之后  还小于4 跳CALSYS2
3106              否则跳CALSYS4
3107          ******************************************************************/
3108          void CALSYS3(void) 
3109          {  
3110   1          RR4=RR4+1;
3111   1          
3112   1          HL=HL+1;
3113   1          
3114   1          if(RR4<4)       //RR4+1之后 还是小于4的话  跳至CALSYS2
3115   1          {
3116   2              CALSYS2();
3117   2          }
3118   1          else
3119   1          {
3120   2              CALSYS4();
3121   2          }
3122   1      }          
3123            
3124          /******************************************************************
3125          CALSYS4 函数
3126              未找到高压点  让SYSL=0 结束
3127              应该是让收缩压为0
3128          ******************************************************************/
3129          void CALSYS4(void)      
3130          {    
3131   1          SYSL=0;         //让收缩压为0   
3132   1      }              
3133           
3134          /******************************************************************
3135          CALSYS5 函数
3136              INSERT一次以后 AA=PA0 
3137              SYSL=AA;
3138              在转到CALSYS5前 RR4的值 要用到
3139          ******************************************************************/
3140          void CALSYS5(void)    
3141          {
3142   1          INSERT();           //RR4的值代入 
3143   1          
3144   1          AA=PA0;             //保存高压点的位置 
3145   1          
3146   1          SYSL=AA;            //找到高压点
3147   1      }
3148          
3149          
3150          /*****************************************************************
3151          ACQDATA:
3152              类似汇编程序中的ACQDATA    重新进入JCL时,在C语言里等待20ms响应
3153              24位转换16位  同时满足压力值*80  以满足汇编算法
C51 COMPILER V9.54   NIBP_JC                                                               06/04/2018 13:55:01 PAGE 52  

3154          ******************************************************************/
3155          void ACQDATA(void)
3156          {   
3157   1          BUF[OPTR]=(ADC_Avg_Data-Init_Offset)/ADC_Ratio;
3158   1      }
3159          
3160          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7342    ----
   CONSTANT SIZE    =    117    ----
   XDATA SIZE       =    752    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
